<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GAMES105</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The note of GAMES105">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><div>GAMES105</div></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="Introduction.html"><strong aria-hidden="true">2.</strong> Introduction to 3D Character Animation</a></li><li class="chapter-item expanded "><a href="Math.html"><strong aria-hidden="true">3.</strong> Math Background</a></li><li class="chapter-item expanded "><a href="Forward.html"><strong aria-hidden="true">4.</strong> Character Kinematics:Forward and Inverse Kinematics</a></li><li class="chapter-item expanded "><a href="Keyframe.html"><strong aria-hidden="true">5.</strong> Character Kinematics (cont.) &amp; Keyframe Animation</a></li><li class="chapter-item expanded "><a href="Data-driven.html"><strong aria-hidden="true">6.</strong> Data-driven Character Animation</a></li><li class="chapter-item expanded "><a href="Learning-based.html"><strong aria-hidden="true">7.</strong> Statistical Models of Human Motion</a></li><li class="chapter-item expanded "><a href="cont.html"><strong aria-hidden="true">8.</strong> Learning-based Character Animation</a></li><li class="chapter-item expanded "><a href="Skinning.html"><strong aria-hidden="true">9.</strong> Skinning</a></li><li class="chapter-item expanded "><a href="Simulation.html"><strong aria-hidden="true">10.</strong> Physics-based Simulation and Articulated Rigid Bodies</a></li><li class="chapter-item expanded "><a href="Actuating.html"><strong aria-hidden="true">11.</strong> Actuating Simulated Characters</a></li><li class="chapter-item expanded "><a href="Controlling.html"><strong aria-hidden="true">12.</strong> Controlling Characters</a></li><li class="chapter-item expanded "><a href="Learning.html"><strong aria-hidden="true">13.</strong> Learning to Walk</a></li><li class="chapter-item expanded "><a href="Optimal.html"><strong aria-hidden="true">14.</strong> Optimal Control and Reinforcement Learning</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GAMES105</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CaterpillarStudyGroup/GAMES105_mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>P4</p>
<h2 id="welcome--course-information"><a class="header" href="#welcome--course-information">Welcome &amp; Course Information</a></h2>
<ul>
<li>Instructor: \( \quad \quad \quad \)Libin Liu (<a href="http://libliu.info">http://libliu.info</a>)</li>
<li>Website: \( \quad \quad \quad \) <a href="https://games-105.github.io/">https://games-105.github.io/</a></li>
<li>Lecture: \( \quad \quad\quad  \) Monday 8:00PM to 9:00PM (12 Weeks)</li>
<li>Prerequisites: \( \quad  \) linear algebra, calculus,<br />
\( \quad \quad \quad \quad\quad \quad\) programming skills (python),<br />
\( \quad \quad \quad \quad\quad \quad\) probability theory, mechanics, ML, RL…</li>
<li>Exercise:
<ul>
<li>Codebase: \( \quad  \)<a href="https://github.com/GAMES-105/GAMES-105">https://github.com/GAMES-105/GAMES-105</a></li>
<li><strong>Submission</strong>: \( \quad  \)<a href="http://cn.ces-alpha.org/course/register/GAMES-105-Animation-2022/">http://cn.ces-alpha.org/course/register/GAMES-105-Animation-2022/</a></li>
<li><strong>Register code</strong>: \( \quad  \)<strong>GAMES-FCA-2022</strong></li>
</ul>
</li>
<li>BBS: \( \quad \quad \quad \quad \quad\)<a href="https://github.com/GAMES-105/GAMES-105/discussions">https://github.com/GAMES-105/GAMES-105/discussions</a></li>
<li>QQ Group: \( \quad \quad  \quad\)533469817</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>P7</p>
<h1 id="3d-computer-graphics"><a class="header" href="#3d-computer-graphics">3D Computer Graphics</a></h1>
<p><img src="./assets/01-02.png" alt="" /></p>
<p>P10</p>
<h2 id="3d-computer-animation"><a class="header" href="#3d-computer-animation">3D Computer Animation</a></h2>
<p><img src="./assets/01-03.png" alt="" /></p>
<blockquote>
<p>✅ 仿真，用于描述客观事物，它们的运动规律可以用精确的数来描述。GAMES103<br />
✅ 动画，用于描述有主观意志的事物，使用统计的方式来对它们的行为建模(例如AI建模)。 GAMES105</p>
</blockquote>
<p>P11</p>
<h2 id="why-do-we-study-character-animation"><a class="header" href="#why-do-we-study-character-animation">Why Do We Study Character Animation</a></h2>
<ul>
<li>A character typically has 20+ joints, or 50-100+ parameters
<ul>
<li>It is not super high-dimensional, so most animation can be created manually, by posing the character at keyframes</li>
<li><strong>Labor-intensive, not for interactive applications</strong></li>
</ul>
</li>
</ul>
<p><img src="./assets/01-4.png" alt="" /></p>
<ul>
<li>Character animation techniques
<ul>
<li><strong>Understanding the mechanism behind motions and behaviors</strong></li>
<li>Smart editing of animation/ Reuse animation / Generate new animation</li>
<li><strong>“Compute-intensive”</strong></li>
</ul>
</li>
</ul>
<p><img src="./assets/01-05.png" alt="" /></p>
<blockquote>
<p>✅ 计算机角色动画把原本劳动密集型的动画师工作变成计算密集型的工作。</p>
</blockquote>
<p>P13</p>
<h1 id="character-animation-pipeline"><a class="header" href="#character-animation-pipeline">Character Animation Pipeline</a></h1>
<p><img src="./assets/01-06.png" alt="" /></p>
<p>P15</p>
<h2 id="where-does-a-motion-come-from"><a class="header" href="#where-does-a-motion-come-from">Where does a Motion Come From</a></h2>
<p>根据是否使用物理，把角色动画分为两大类。</p>
<p><img src="./assets/01-10.png" alt="" /></p>
<p>P16</p>
<h3 id="keyframe-basedkinematic-approaches"><a class="header" href="#keyframe-basedkinematic-approaches">Keyframe-based/Kinematic Approaches</a></h3>
<p><img src="./assets/01-08.png" alt="" /> </p>
<blockquote>
<p>✅ 基于运动学直接更新角色状态，运动可以不符合物理规律。</p>
</blockquote>
<p>P18</p>
<h3 id="physics-baseddynamic-approaches"><a class="header" href="#physics-baseddynamic-approaches">Physics-based/Dynamic Approaches</a></h3>
<p><img src="./assets/01-09.png" alt="" /></p>
<blockquote>
<p>✅ 基于物理，但实际情况会有简化，不能直接干预角色姿态。 </p>
</blockquote>
<p>P19</p>
<h2 id="control-level"><a class="header" href="#control-level">Control Level</a></h2>
<p>根据控制方式的高度，可以分为Low Level和Heigh Level</p>
<p>P20</p>
<h3 id="low-level-control"><a class="header" href="#low-level-control">low-level control</a></h3>
<p><img src="./assets/01-11.png" alt="" /></p>
<blockquote>
<p>✅ 对每一帧每一个姿态进行精确控制每个细节。<br />
✅ 优点：精确控制；缺点：低效。</p>
</blockquote>
<p>P21</p>
<h3 id="high-level-control"><a class="header" href="#high-level-control">high-level control</a></h3>
<p><img src="./assets/01-12.png" alt="" /></p>
<blockquote>
<p>✅ 控制高级目标。</p>
</blockquote>
<h1 id="keyframe-basedkinematic-approaches-1"><a class="header" href="#keyframe-basedkinematic-approaches-1">Keyframe-based/Kinematic Approaches</a></h1>
<p>P24</p>
<h2 id="disneys-12-principles-of-animation"><a class="header" href="#disneys-12-principles-of-animation">Disney’s 12 Principles of Animation</a></h2>
<p><img src="./assets/01-13.png" alt="" /></p>
<p>[<a href="http://the12principles.tumblr.com/">http://the12principles.tumblr.com/</a>]</p>
<blockquote>
<p>✅ 在动画师总结的准则里隐藏了物理规则和艺术夸张</p>
</blockquote>
<h2 id="keyframe-animation"><a class="header" href="#keyframe-animation">Keyframe Animation</a></h2>
<blockquote>
<p>✅ 这是一种非常low level的控制方法，可以保证所有细节，但非常慢</p>
</blockquote>
<p>P26</p>
<h3 id="forward-kinematics"><a class="header" href="#forward-kinematics">Forward Kinematics</a></h3>
<p><img src="./assets/01-14.png" alt="" /></p>
<p><strong>Given</strong> rotations of every joints<br />
<strong>Compute</strong> position of end-effectors</p>
<p>P27</p>
<h3 id="inverse-kinematics"><a class="header" href="#inverse-kinematics">Inverse Kinematics</a></h3>
<p><img src="./assets/01-15.png" alt="" /></p>
<p><strong>Given</strong> position of end-effectors<br />
<strong>Compute</strong> rotations of every joints</p>
<p>P28</p>
<h3 id="interpolation"><a class="header" href="#interpolation">Interpolation</a></h3>
<p><img src="./assets/01-16.png" alt="" /></p>
<h2 id="motion-capture"><a class="header" href="#motion-capture">Motion Capture</a></h2>
<p>动捕设备、视频动捕，把动捕角色应用到角色身上，需要经过重定向<br />
动作捕捉和重放，不能产生新的数据</p>
<blockquote>
<p>✅ 光学动捕、视频动捕、穿戴传感器动捕。</p>
</blockquote>
<p>P34</p>
<h3 id="motion-retargeting"><a class="header" href="#motion-retargeting">Motion Retargeting</a></h3>
<p><img src="./assets/01-17.png" alt="" /></p>
<p><strong>Given</strong> motions of a source character<br />
<strong>Compute</strong> motions for target characters with</p>
<ul>
<li>different skeleton sizes</li>
<li>different number of bones</li>
<li>different topologies</li>
<li>……</li>
</ul>
<p>P36</p>
<h2 id="motion-graphs--state-machines"><a class="header" href="#motion-graphs--state-machines">Motion Graphs / State Machines</a></h2>
<p><img src="./assets/01-18.png" alt="" /></p>
<blockquote>
<p>✅ 把捕出来的动作进行分解和重组，生成新的动作。</p>
</blockquote>
<p>P37</p>
<h3 id="motion-graphs"><a class="header" href="#motion-graphs">Motion Graphs</a></h3>
<p><img src="./assets/01-19.png" alt="" /></p>
<blockquote>
<p>✅ 给一段任意的动作，寻找能够构建状态机切换的位。 </p>
</blockquote>
<p>P38</p>
<h3 id="motion-graphs的改进---interactively-controlled-boxing"><a class="header" href="#motion-graphs的改进---interactively-controlled-boxing">Motion Graphs的改进 - Interactively Controlled Boxing</a></h3>
<p><img src="./assets/01-20.png" alt="" /></p>
<p>[Heck and Gleicher 2007, Parametric Motion Graphs]</p>
<blockquote>
<p>✅ 对Motion Graph的改进，比如一个节点中有很多动作，对这些动作进行插值，来实现精确控制。</p>
</blockquote>
<p>P39</p>
<h3 id="motion-graphs的高级应用"><a class="header" href="#motion-graphs的高级应用">Motion Graphs的高级应用</a></h3>
<p><strong>Character Animation in Two-Player Adversarial Games</strong><br />
KEVIN WAMPLER,ERIK ANDERSEN, EVAN HERBST, YONGJOON LEE, and ZORAN POPOVIC Univoersity of Washington</p>
<p><strong>Near-optimal Character Animation with Continuous Control</strong><br />
Adrien Treuille  \(\quad\)   Yongjoon Lee   \(\quad\)  Zoran Popovic<br />
University of Washington</p>
<blockquote>
<p>✅ Motion Graph＋AI，实现高级控制<br />
✅ 例如：AI使用Motion Graph，通过选择合适的边，进行执行，完成高级语义。</p>
</blockquote>
<p>P42</p>
<h3 id="complex-motion-graphs"><a class="header" href="#complex-motion-graphs">Complex Motion Graphs</a></h3>
<p><img src="./assets/01-21.png" alt="" /></p>
<blockquote>
<p>✅ 动作图非常复杂，容易出BUG．</p>
</blockquote>
<p>P43</p>
<h2 id="motion-mathing"><a class="header" href="#motion-mathing">Motion Mathing</a></h2>
<blockquote>
<p>✅ 改进，Motion Graph的动作都是完整的片断，可以把动作再分细一点，切到每一帧。<br />
✅ 不是完整地播放一段动作，而是每一帧结束后，通过最近邻搜索找到一个新的姿态，<br />
✅ 满足：（1）接近控制目标（2）动作连续<br />
✅ 关键：（1）定义距离函数（2）设计动作库</p>
</blockquote>
<p>P45</p>
<h2 id="learning-based-approaches"><a class="header" href="#learning-based-approaches">Learning-based Approaches</a></h2>
<p><img src="./assets/01-22.png" alt="" /> </p>
<blockquote>
<p>✅ 对角色动作的内在规律去理解和建模，从数据学习统计规律。<br />
✅ 生成模型：只需要采足够的动作去给模型就能生成新的动作。<br />
✅ 不需要手工作切分、生成状态机</p>
</blockquote>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2020</td><td>Local Motion Phases for Learning Multi-Contact Character Movements</td><td></td><td></td><td></td></tr>
<tr><td></td><td>2021</td><td>Character Controllers Using Motion VAEs</td><td></td><td></td><td></td></tr>
</tbody></table>
<p>P49</p>
<h2 id="cross-modal-motion-synthesis"><a class="header" href="#cross-modal-motion-synthesis">Cross-Modal Motion Synthesis</a></h2>
<ul>
<li>Audio-driven animation
<ul>
<li>Music to dance</li>
<li>Co-speech gesture</li>
<li>……</li>
</ul>
</li>
<li>Natural language to animation
<ul>
<li>Descriptions to actions</li>
<li>Scripts to performance</li>
<li>……</li>
</ul>
</li>
</ul>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2022</td><td>Rhythmic Gesticulator</td><td>✅ 语言和动作都有内存的统计规律，把两种统计模型之间建关系，实现跨模态生成。</td><td><img src="./assets/01-23.png" alt="" /></td><td></td></tr>
</tbody></table>
<p><img src="./assets/01-23.png" alt="" /></p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><img src="./assets/01-24.png" alt="" /></p>
<h1 id="physics-baseddynamic-approaches-1"><a class="header" href="#physics-baseddynamic-approaches-1">Physics-based/Dynamic Approaches</a></h1>
<blockquote>
<p>✅ 不直接生成姿态，而是控制量（例如力），通过物理仿真真正改变角色。</p>
</blockquote>
<p><img src="./assets/01-26.png" alt="" /><br />
<img src="./assets/01-27.png" alt="" /></p>
<p>P59</p>
<h2 id="ragdoll-simulation"><a class="header" href="#ragdoll-simulation">Ragdoll Simulation</a></h2>
<p><img src="./assets/01-28.png" alt="" /></p>
<blockquote>
<p>✅ 用于人死掉、失去意识、突发事件来不及响应的情况。</p>
</blockquote>
<p>P63</p>
<h2 id="物理仿真角色动画的应用"><a class="header" href="#物理仿真角色动画的应用">物理仿真角色动画的应用</a></h2>
<p><img src="./assets/01-30.png" alt="" /></p>
<p>[DeepMotion: Virtual Reality Tracking]</p>
<p>[Ye et al. 2022: Neural3Points]</p>
<p>[Yang et al. 2022: Learning to Use Chopsticks]</p>
<blockquote>
<p>✅ 抓住手指动作细节
P67</p>
</blockquote>
<p>P68</p>
<h2 id="物理角色的建模方法"><a class="header" href="#物理角色的建模方法">物理角色的建模方法</a></h2>
<p><img src="./assets/01-32.png" alt="" /></p>
<blockquote>
<p>✅ 构建完整的神经系统和肌肉系统。<br />
✅ （1）神经肌肉机理不清楚。<br />
✅ （2）自由度高，仿真效率低。<br />
✅ 所以实际上会做简化，对关节力矩进行建模</p>
</blockquote>
<p><img src="./assets/01-33.png" alt="" /></p>
<blockquote>
<p>✅ 用关节力矩仿真肌肉的力。</p>
</blockquote>
<p>P70</p>
<h3 id="force--torque"><a class="header" href="#force--torque">Force &amp; Torque</a></h3>
<p><img src="./assets/01-34.png" alt="" /></p>
<p>P71</p>
<h2 id="keyfrmae-control"><a class="header" href="#keyfrmae-control">Keyfrmae Control</a></h2>
<h3 id="proportional-derivative-pd-control"><a class="header" href="#proportional-derivative-pd-control">Proportional-Derivative (PD) Control</a></h3>
<p><img src="./assets/01-35.png" alt="" /></p>
<blockquote>
<p>✅ 根据当前状态与目标状态的差距，计算出当前状态运动到目标状态所需要的力矩。</p>
</blockquote>
<p>P72</p>
<h3 id="tracking-controllers"><a class="header" href="#tracking-controllers">Tracking Controllers</a></h3>
<p><img src="./assets/01-36.png" alt="" /></p>
<blockquote>
<p>✅ 比如要做一个动作，给出目标高度的轨迹，采用PD控制生成每个关节的力矩，大概能产生要做的动作 </p>
</blockquote>
<blockquote>
<p>[Hodgins and Wooten 1995, Animating Human Athletics]</p>
</blockquote>
<p>P76</p>
<h3 id="trajectory-crafting"><a class="header" href="#trajectory-crafting">Trajectory Crafting</a></h3>
<p>NaturalMotion - Endorphin</p>
<blockquote>
<p>✅ 关键帧→力→仿真</p>
</blockquote>
<p>实际上这个方法很难用起来，因为调整仿真参数甚至比直接做关键帧更花时间。</p>
<p>P79</p>
<h2 id="spacetimetrajectory-optimization"><a class="header" href="#spacetimetrajectory-optimization">Spacetime/Trajectory Optimization</a></h2>
<blockquote>
<p>✅ 用优化方法实现，结合重定向</p>
</blockquote>
<p>[Liu et al 2010. SAMCON]</p>
<p>[Wampler and Popović. 2009. Optimal gait and form for animal locomotion]</p>
<p>[Hamalainen et al. 2020, Visualizing Movement Control Optimization Landscapes]</p>
<blockquote>
<p>✅ 这是高维非线性优化问题，非常准解。</p>
</blockquote>
<p>P83</p>
<h2 id="abstract-models-简化模型"><a class="header" href="#abstract-models-简化模型">Abstract Models 简化模型</a></h2>
<p>通过简化模型实现对一些动作的控制，但只能做简单动作</p>
<h3 id="simbicon"><a class="header" href="#simbicon">SIMBICON</a></h3>
<p><img src="./assets/01-38.png" alt="" /></p>
<blockquote>
<p>✅ 用简化模型把想要的动作描述出来，来指导角色控制。<br />
✅ 基于此实现稳定的多技能的控制策略。<br />
✅ 控制简化、缺少细节，走路像机器人。<br />
✅ 简化模型思路，可以实现对一些动作进行控制，且结果鲁棒，允许使用外力与角色交互。<br />
✅ 缺点：只能走路，不能复杂动作。 </p>
</blockquote>
<p>P85</p>
<h3 id="inverted-pendulum-model"><a class="header" href="#inverted-pendulum-model">Inverted Pendulum Model</a></h3>
<p><img src="./assets/01-039.png" alt="" /></p>
<p>[Coros et al. 2010]</p>
<p>P87</p>
<h2 id="reinforcement-learning"><a class="header" href="#reinforcement-learning">Reinforcement Learning</a></h2>
<p><img src="./assets/01-40.png" alt="" /></p>
<p>P89</p>
<h3 id="drl-based-tracking-controllers"><a class="header" href="#drl-based-tracking-controllers">DRL-based Tracking Controllers</a></h3>
<p>[Liu et al. 2016. ControlGraphs]</p>
<p>[Liu et al. 2018]</p>
<p>[Peng et al. 2018. DeepMimic]</p>
<blockquote>
<p>✅ 利用DRL做复杂动作，但还只是动作复现。</p>
</blockquote>
<p>P90</p>
<h3 id="multi-skill-characters"><a class="header" href="#multi-skill-characters">Multi-skill Characters</a></h3>
<h4 id="引入状态机完成更复杂动作"><a class="header" href="#引入状态机完成更复杂动作">引入状态机，完成更复杂动作。</a></h4>
<p>State Machines of Tracking Controllers</p>
<h4 id="引入motion-maching"><a class="header" href="#引入motion-maching">引入Motion Maching</a></h4>
<p><img src="./assets/01-41.png" alt="" /></p>
<p>[Liu et al. 2017: Learning to Schedule Control Fragments]</p>
<h2 id="hierarchical-controllers"><a class="header" href="#hierarchical-controllers">Hierarchical Controllers</a></h2>
<p>在高级指令控制下，综合使用动作来完成功能</p>
<p>Generative Control Policies</p>
<table><thead><tr><th>运动生成模型</th><th>控制生成模型</th></tr></thead><tbody>
<tr><td><img src="./assets/01-42.png" alt="" /></td><td><img src="./assets/01-43.png" alt="" /></td></tr>
</tbody></table>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p><img src="./assets/01-44.png" alt="" /></p>
<blockquote>
<p>✅ 回顾计算机角色动化领域最近30年主要研究方向。 </p>
</blockquote>
<p>P102</p>
<h1 id="about-this-course"><a class="header" href="#about-this-course">About This Course</a></h1>
<ul>
<li>
<p>What will not be covered</p>
<ul>
<li>How to use Maya/Motion Builder/Houdini/Unity/Unreal Engine…</li>
<li>How to become an animator</li>
</ul>
</li>
<li>
<p>What will be covered</p>
<ul>
<li>
<p>Methods, theories, and techniques behind animation tools</p>
<ul>
<li>Kinematics of characters</li>
<li>Physics-based simulation</li>
<li>Motion control</li>
</ul>
</li>
<li>
<p>Ability to create an interactive character</p>
</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline"><a class="header" href="#outline">Outline</a></h1>
<ul>
<li>
<p>Review of Linear Algebra</p>
<ul>
<li>Vector and Matrix</li>
<li>Translation, Rotation, and Transformation</li>
</ul>
</li>
<li>
<p>Representations of 3D rotation</p>
<ul>
<li>Rotation matrices</li>
<li>Euler angles</li>
<li>Rotation vectors/Axis angles</li>
<li>Quaternions</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 这节课大部分内容会跳过，因为前面课程讲过好多遍了</p>
</blockquote>
<p>P3</p>
<h1 id="review-of-linear-algebra"><a class="header" href="#review-of-linear-algebra">Review of Linear Algebra</a></h1>
<h2 id="vectors-and-matrices"><a class="header" href="#vectors-and-matrices">Vectors and Matrices</a></h2>
<p><em>a few slides were modified from GAMES-101 and GAMES-103</em></p>
<p>P24</p>
<blockquote>
<p>✅ 两个单位向量的叉乘不一定是单位向量。<br />
✅ 要得到方向，应先叉乘再单位化<br />
✅ \(n=\frac{a\times b}{||a\times b||}\)（正确）、\(n=\frac{a}{||a||} \times \frac{b}{||b||}\)（错误）</p>
</blockquote>
<p>P26</p>
<h3 id="how-to-find-the-rotation-between-vectors"><a class="header" href="#how-to-find-the-rotation-between-vectors">How to find the rotation between vectors?</a></h3>
<h4 id="问题描述"><a class="header" href="#问题描述">问题描述</a></h4>
<blockquote>
<p>✅ 已知\(a,b\) , 求旋转。</p>
</blockquote>
<p><img src="./assets/02-01.png" alt="" /></p>
<h4 id="求旋转轴"><a class="header" href="#求旋转轴">求旋转轴</a></h4>
<p>P27</p>
<p>Any vector in the bisecting plane can be the axis</p>
<p>$$
𝒖 =\frac{𝒂 × 𝒃}{||𝒂 × 𝒃||} 
$$</p>
<h4 id="求旋转角"><a class="header" href="#求旋转角">求旋转角</a></h4>
<p>P28</p>
<p>The minimum rotation:<br />
$$
\theta = \mathrm{arg} \cos \frac{a\cdot b}{||a||||b||} 
$$</p>
<p><img src="./assets/02-02.png" alt="" /></p>
<blockquote>
<p>✅ \(u\) 为旋转轴，\( \theta \) 为旋转角。</p>
</blockquote>
<p>P33</p>
<h3 id="how-to-rotate-a-vectors"><a class="header" href="#how-to-rotate-a-vectors">How to rotate a vectors?</a></h3>
<h4 id="问题描述-1"><a class="header" href="#问题描述-1">问题描述</a></h4>
<p>已知 \(a\) 和旋转 \((𝒖, \theta )\) 求终点 \(b\)</p>
<p><img src="./assets/02-3.png" alt="" /></p>
<h4 id="解题方法"><a class="header" href="#解题方法">解题方法</a></h4>
<p>\(a\) 移动到 \(b\) 看作是先移动 \(𝒗\) 再移动 \(t\)，分别计算 \(𝒗\) 和 \(t\) 的方向和长度。</p>
<p>$$
𝒗 \gets  𝒖 \times  𝒂
$$</p>
<p>$$
𝒕 \gets 𝒖 \times 𝒗 = 𝒖 \times( 𝒖 \times 𝒂)
$$</p>
<p><img src="./assets/02-04.png" alt="" /></p>
<h4 id="计算过程"><a class="header" href="#计算过程">计算过程</a></h4>
<p>P35</p>
<p>$$
𝒗 = (\sin \theta) 𝒖 \times  𝒂
𝒕 =(1-\cos \theta ) 𝒖 \times( 𝒖 \times 𝒂)
$$</p>
<h4 id="rodrigues-rotation-formula"><a class="header" href="#rodrigues-rotation-formula">Rodrigues' rotation formula</a></h4>
<p>$$
𝒃 = 𝒂 + (\sin \theta) 𝒖 × 𝒂 + (1-\cos \theta ) 𝒖 \times( 𝒖 \times 𝒂)
$$</p>
<p>P53</p>
<h2 id="matrix"><a class="header" href="#matrix">Matrix</a></h2>
<h3 id="matrix-form-of-cross-product"><a class="header" href="#matrix-form-of-cross-product">Matrix Form of Cross Product</a></h3>
<p>$$
\begin{align*}
c=a\times b= &amp; \begin{bmatrix}
a_yb_z-a_zb_y \\
a_zb_x-a_xb_z \\
a_xb_y-a_yb_x
\end{bmatrix}\\
= &amp; \begin{bmatrix}
0 &amp; -a_z &amp; a_y \\
a_z &amp; 0 &amp; -a_x \\
-a_y &amp; a_x &amp; 0
\end{bmatrix}\begin{bmatrix}
b_x \\
b_y  \\
b_z
\end{bmatrix}=[a]_\times b
\end{align*}
$$</p>
<p>$$ 
[a]_\times +[a]^ \mathbf{T} _\times =0 \quad \quad \mathrm{skewsymmetric} 
$$ </p>
<p>P56</p>
<p>$$
\begin{align*}
a \times b = &amp;[a] _ \times b  \\
a \times (b \times c) = &amp; [a] _ \times ( [b] _ \times c ) \\
=  &amp; [a] _ \times [b] _ \times c  \\
a \times (a \times c) = &amp; [a] ^2 _ \times  b \\
(a \times b) \times c = &amp; [a\times b] _ \times  c \\
\end{align*}
$$</p>
<blockquote>
<p>✅ 最后一个公式注意一下，叉乘不满足结合律。</p>
</blockquote>
<p>P57</p>
<h3 id="how-to-rotate-a-vectors-1"><a class="header" href="#how-to-rotate-a-vectors-1">How to rotate a vectors?</a></h3>
<h4 id="问题描述-2"><a class="header" href="#问题描述-2">问题描述</a></h4>
<p>已知 \(a\) 和旋转 \((𝒖, \theta )\) 求终点 \(b\)</p>
<h4 id="把前面的结论转化为矩阵形式"><a class="header" href="#把前面的结论转化为矩阵形式">把前面的结论转化为矩阵形式</a></h4>
<p>$$
\begin{align*}
b = &amp; a+(\sin \theta )u \times a +(1-\cos \theta)u \times(u \times a) \\
b = &amp; (I+(\sin \theta ))[u]_ \times + (1-(\cos \theta )[u]^2_ \times ) a \\
= &amp; Ra
\end{align*}
$$</p>
<blockquote>
<p>✅ 把前面的叉乘公式转化为点乘形式</p>
</blockquote>
<h4 id="结论"><a class="header" href="#结论">结论</a></h4>
<p>Rodrigues' rotation formula</p>
<p>$$
R = I+(\sin \theta )[u]_ \times + (1-\cos \theta )[u]^2_ \times
$$</p>
<blockquote>
<p>✅ \(R\) 是旋转 \((u, \theta )\) 对应的旋转矩阵。</p>
</blockquote>
<p>P62</p>
<h3 id="determinant-of-a-matrix"><a class="header" href="#determinant-of-a-matrix">Determinant of a Matrix</a></h3>
<h4 id="定义"><a class="header" href="#定义">定义</a></h4>
<p><img src="./assets/02-07-1.png" alt="" /></p>
<blockquote>
<p>✅ 行列式的计算：红色相乘减蓝色相乘。</p>
</blockquote>
<p>P63</p>
<h4 id="公式"><a class="header" href="#公式">公式</a></h4>
<ul>
<li>det \(I = 1\)</li>
<li>det \(AB = \text{ det } A ∗ \text{det } B\)</li>
<li>det \(A^T\) = det \(A\)</li>
<li>If \(A\) is invertible，det \(A^{−1}\) = \((\text{det } A)^{−1}\)</li>
<li>If \(U\) is orthogonal，\(\text{det } U = ± 1\)</li>
</ul>
<p>P64</p>
<h4 id="cross-product-as-a-determinant"><a class="header" href="#cross-product-as-a-determinant">Cross Product as a Determinant</a></h4>
<p>$$
\begin{align*}
c=a\times b= &amp; \begin{bmatrix}
a_yb_z-a_zb_y \\
a_zb_x-a_xb_z \\
a_xb_y-a_yb_x
\end{bmatrix}\\
= &amp; \text{det } \begin{bmatrix}
i &amp; j &amp; k \\
a_x &amp; a_y &amp; a_z \\
b_x &amp; b_y &amp; b_z
\end{bmatrix}
\end{align*}
$$</p>
<blockquote>
<p>✅ 用行列式运算规则来计算叉乘结果。</p>
</blockquote>
<p>P66</p>
<h3 id="eigenvalues-and-eigenvectors"><a class="header" href="#eigenvalues-and-eigenvectors">Eigenvalues and Eigenvectors</a></h3>
<p>For a matrix \(A\), if a <strong>nonzero</strong> vector \(x\) satisfies<br />
$$
Ax=\lambda x
$$</p>
<p>Then:<br />
\(\lambda\): an eigenvalue of \(A\)<br />
\(x\): an eigenvector of \(A\)</p>
<p>Especially, a \(3\times 3\) <strong>orthogonal</strong> matrix \(U\)<br />
has at least one real eigenvalue: \(\lambda=\text{det } U = ±1\)</p>
<p>P67</p>
<h3 id="rigid-transformation"><a class="header" href="#rigid-transformation">Rigid Transformation</a></h3>
<p>Translation, rotation, and coordinate transformation </p>
<p><img src="./assets/02-07.png" alt="" /></p>
<blockquote>
<p>✅ 刚体变换不能改变形状和大小，因此没有Scaling</p>
</blockquote>
<p>P69</p>
<h4 id="scaling"><a class="header" href="#scaling">Scaling</a></h4>
<p><img src="./assets/02-08.png" alt="" /></p>
<p>P70</p>
<h4 id="translation"><a class="header" href="#translation">Translation</a></h4>
<p><img src="./assets/02-9.png" alt="" /></p>
<p>P72</p>
<h4 id="rotation"><a class="header" href="#rotation">Rotation</a></h4>
<p><img src="./assets/02-10.png" alt="" /></p>
<p>P73</p>
<h2 id="rotation-matrix"><a class="header" href="#rotation-matrix">Rotation Matrix</a></h2>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<ul>
<li>Rotation matrix is orthogonal:</li>
</ul>
<p>$$
R^{-1}=R^{T}  \quad R^TR=RR^T=1
$$</p>
<ul>
<li>Determinant of \(R\)<br />
$$
\text{det } R = + 1
$$</li>
<li>Rotation maintains length of vectors
$$
||Rx|| = ||x||
$$</li>
</ul>
<blockquote>
<p>✅ 公式2：\(R\) 不会改变左、右手系<br />
✅ 公式3：\(R\) 是刚性变换，不改变大小</p>
</blockquote>
<p>P75</p>
<h3 id="combination-of-rotations"><a class="header" href="#combination-of-rotations">Combination of Rotations</a></h3>
<p><img src="./assets/02-11.png" alt="" /></p>
<p>P76</p>
<h3 id="rotation-around-coordinate-axes"><a class="header" href="#rotation-around-coordinate-axes">Rotation around Coordinate Axes</a></h3>
<p><img src="./assets/02-12.png" alt="" /></p>
<p>$$
R_x(\alpha )=\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos\alpha  &amp; -\sin \alpha \\
0 &amp; \sin \alpha  &amp; \cos \alpha 
\end{pmatrix}
$$</p>
<p>$$
R_y(\beta )=\begin{pmatrix}
\cos \beta &amp; 0 &amp; \sin \beta \\
0 &amp; 1  &amp; 0  \\
-\sin \beta &amp; 0   &amp; \cos \beta 
\end{pmatrix}
$$</p>
<p>$$
R_z(\gamma  )=\begin{pmatrix}
\cos \gamma &amp; -\sin \gamma &amp; 0 \\
\sin \gamma &amp; \cos \gamma  &amp; 0  \\
0 &amp; 0   &amp; 1 
\end{pmatrix}
$$</p>
<blockquote>
<p>✅ 沿着哪个轴转，那个轴上的坐标不会改变。<br />
✅ 三个基本旋转可以组合出复杂旋转。</p>
</blockquote>
<p>P79</p>
<h2 id="rotation-axis-and-angle"><a class="header" href="#rotation-axis-and-angle">Rotation Axis and Angle</a></h2>
<p>Rotation matrix \(R\) has a real eigenvalue: +1<br />
$$
Ru=u
$$</p>
<p>In other words, \(R\) can be considered as a rotation around axis \(u\) by some angle \(\theta \)<br />
How to find axis 𝒖 and angle \(\theta \)?</p>
<p><img src="./assets/02-13.png" alt="" /></p>
<blockquote>
<p>✅ 用 \(R\) 旋转时，向量 \(u\) 不会变化。<br />
✅ 对于任意 \(R\)，都存在这样一个 \(u\).<br />
✅ \(u\) 是 \(R\) 的旋转轴。</p>
</blockquote>
<p>P80</p>
<h3 id="根据旋转矩阵求轴角"><a class="header" href="#根据旋转矩阵求轴角">根据旋转矩阵求轴角</a></h3>
<p><img src="./assets/02-14.png" alt="" /></p>
<p>P81</p>
<p><img src="./assets/02-015.png" alt="" /></p>
<blockquote>
<p>✅ \({u}' \) 与 \({u} \) 共线，\({u}' \) 单位化得到 \({u} \)．<br />
✅ \(q\) 和 \(-q\) 两种表示方法会引入插值问题，需要注意。</p>
</blockquote>
<p>P82</p>
<p>$$
u\gets {u}' =\begin{bmatrix}
r_{32}-r_{23}  \\
r_{13}-r_{31}  \\
r_{21}-r_{12} 
\end{bmatrix}
$$</p>
<p>$$
\text{When }  R\ne R^T \Leftrightarrow \sin \theta \ne 0\Leftrightarrow \theta \ne 0^{\circ} 
\text{ or }  180^{\circ} 
$$</p>
<p>P83</p>
<h3 id="基于罗德里格公式求轴角"><a class="header" href="#基于罗德里格公式求轴角">基于罗德里格公式求轴角</a></h3>
<p><img src="./assets/02-17.png" alt="" /></p>
<blockquote>
<p>✅ 从 \(R\) 的公式也能得出相同的结论<br />
✅ \(u  →  {u}'  →  \)旋转角度</p>
</blockquote>
<p>P85</p>
<h3 id="旋转矩阵的意义"><a class="header" href="#旋转矩阵的意义">旋转矩阵的意义</a></h3>
<h3 id="旋转"><a class="header" href="#旋转">旋转</a></h3>
<p><img src="./assets/02-18.png" alt="" /></p>
<p>P86</p>
<h3 id="旋转--平移"><a class="header" href="#旋转--平移">旋转 + 平移</a></h3>
<p><img src="./assets/02-19.png" alt="" /> </p>
<p>P87</p>
<h1 id="representations-of-3d-rotation"><a class="header" href="#representations-of-3d-rotation">Representations of 3D Rotation</a></h1>
<p>　</p>
<p>P91</p>
<h2 id="旋转矩阵"><a class="header" href="#旋转矩阵">旋转矩阵</a></h2>
<h3 id="parameterization-of-rotation"><a class="header" href="#parameterization-of-rotation">Parameterization of Rotation</a></h3>
<p>旋转矩阵有9个参数，但实际上degrees of freedom (DoF) = 3</p>
<blockquote>
<p>✅ det 只是把空间减少一半，没有降低自由度</p>
</blockquote>
<p>P93</p>
<h3 id="interpolation-1"><a class="header" href="#interpolation-1">Interpolation</a></h3>
<p>What is good interpolation?</p>
<ul>
<li>result is valid at any time \(t\)</li>
<li>Constant speed is preferred</li>
</ul>
<table><thead><tr><th></th><th>平移</th><th>旋转</th></tr></thead><tbody>
<tr><td></td><td><img src="./assets/02-20-1.png" alt="" /></td><td><img src="./assets/02-21.png" alt="" /></td></tr>
<tr><td></td><td>\(x_t=(1-t)x_0+tx_1\)<br> ✅ 平移使用线性插值</td><td>✅ 旋转不适合线性插值。</td></tr>
<tr><td>合法</td><td>✅ 对于任意 \(t\), \(x_t\) 一定是合法的。</td><td></td></tr>
<tr><td>速度可控</td><td>✅ 运动的速度是常数，因此速度可控。</td><td></td></tr>
</tbody></table>
<p>P99</p>
<h3 id="结论-1"><a class="header" href="#结论-1">结论</a></h3>
<ul>
<li>Easy to compose?   \(\quad \quad \quad {\color{Red} \times } \)</li>
</ul>
<blockquote>
<p>✅ 9个参数没有直接的意义，且为了满足正交阵，参数之间是耦合的。</p>
</blockquote>
<ul>
<li>Easy to apply?   \(\quad \quad \quad \quad {\color{Green}  \surd }\)</li>
<li>Easy to interpolate?  \(\quad  \quad {\color{Red} \times } \)</li>
</ul>
<p>P100</p>
<h2 id="euler-angles"><a class="header" href="#euler-angles">Euler angles</a></h2>
<h3 id="basic-rotations"><a class="header" href="#basic-rotations">Basic rotations</a></h3>
<p><img src="./assets/02-22.png" alt="" /> </p>
<p>$$
R_x(\alpha )=\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; \cos\alpha  &amp; -\sin \alpha \\
0 &amp; \sin \alpha  &amp; \cos \alpha 
\end{pmatrix}
$$</p>
<p>$$
R_y(\beta )=\begin{pmatrix}
\cos \beta &amp; 0 &amp; \sin \beta \\
0 &amp; 1  &amp; 0  \\
-\sin \beta &amp; 0   &amp; \cos \beta 
\end{pmatrix}
$$</p>
<p>$$
R_z(\gamma  )=\begin{pmatrix}
\cos \gamma &amp; -\sin \gamma &amp; 0 \\
\sin \gamma &amp; \cos \gamma  &amp; 0  \\
0 &amp; 0   &amp; 1 
\end{pmatrix}
$$</p>
<h3 id="combination-of-three-basic-rotations"><a class="header" href="#combination-of-three-basic-rotations">combination of three basic rotations</a></h3>
<p><strong>Any rotation can be represented as a combination of three basic rotations</strong></p>
<p>P102</p>
<p>Any combination of three basic rotations are allowed<br />
- Excluding those rotate twice around the same axis<br />
- XYZ, XZY, YZX, YXZ, ZYX, ZXY, XYX, XZX, YXY, YZY, ZXZ, ZYZ</p>
<p>P103</p>
<h3 id="conventions-of-euler-angles"><a class="header" href="#conventions-of-euler-angles">Conventions of Euler Angles</a></h3>
<p>intrinsic rotations: axes attached to the <strong>object</strong></p>
<p>$$
R_x(\alpha )R_y(\beta )R_z(\gamma )
$$</p>
<p>extrinsic rotations: axes fixed to the <strong>world</strong></p>
<p>$$
R_z(\gamma )R_y(\beta )R_x(\alpha )
$$</p>
<blockquote>
<p>✅ 使用欧拉角时应先明确所使用的 convetion 和顺序。<br />
✅ 不同的商业软件可能有不同的内置参数。<br />
✅ maya 和 unity 都是 extrinsic.<br />
✅ maya 可选顺序，Unity 固定 Zxy</p>
</blockquote>
<p>P104</p>
<h3 id="gimbal-lock"><a class="header" href="#gimbal-lock">Gimbal Lock</a></h3>
<p>When two local axes are driven into a parallel configuration, 
one degree of freedom is “locked”</p>
<blockquote>
<p>✅ 当其中两个轴共线时，会丢失一个自由度，此时表示不唯一（奇异点）</p>
</blockquote>
<p>P105</p>
<h3 id="结论-2"><a class="header" href="#结论-2">结论</a></h3>
<p><img src="./assets/02-23.png" alt="" /> </p>
<blockquote>
<p>✅ 插值时需注意作用域为 \([-\pi , \pi ]\)，否则容易出现翻转现象。</p>
</blockquote>
<p>P107</p>
<h2 id="rotation-vectors--axis-angles"><a class="header" href="#rotation-vectors--axis-angles">Rotation Vectors / Axis Angles</a></h2>
<p><img src="./assets/02-24-1.png" alt="" /> </p>
<blockquote>
<p>✅ 粗体 \(\theta \)：轴角表示法描述的旋转<br />
✅ 细体 \(\theta \)：以 \(u\) 为轴的旋转角度</p>
</blockquote>
<p><img src="./assets/02-24.png" alt="" /> </p>
<blockquote>
<p>✅ 应用时要先转为旋转矩阵，做旋转组合时也要借助旋转矩阵</p>
</blockquote>
<p>P110</p>
<h3 id="interpolating-rotation-vectors--axis-angles"><a class="header" href="#interpolating-rotation-vectors--axis-angles">Interpolating Rotation Vectors / Axis Angles</a></h3>
<h4 id="线性插值"><a class="header" href="#线性插值">线性插值</a></h4>
<p>可以保证插值结果合法，但不能保证旋转速度恒定</p>
<p><img src="./assets/02-25.png" alt="" /> </p>
<p>P111</p>
<h4 id="匀速插值"><a class="header" href="#匀速插值">匀速插值</a></h4>
<p>可以保证插值结果合法且匀速，但旋转较复杂</p>
<p><img src="./assets/02-25-1.png" alt="" /> </p>
<blockquote>
<p>✅ 这个方法没听懂，可以实现允许插值。</p>
</blockquote>
<p>P112</p>
<h3 id="结论-3"><a class="header" href="#结论-3">结论</a></h3>
<p><img src="./assets/02-25-2.png" alt="" /> </p>
<ul>
<li>Easy to compose?   \(\quad \quad {\color{Green} \surd } \quad \quad \)   But hard to manipulate</li>
<li>Easy to apply?   \(\quad \quad \quad {\color{Red} \times }  \quad \quad \)     Need to convert to matrix</li>
<li>Easy to interpolate?  \(\quad \quad {\color{Green} \surd } \quad \quad \)  Linear interpolation works, but not perfect</li>
<li>No Gimbal lock    \(\quad \quad {\color{Green} \surd } \quad \quad \)  need to deal with singularities</li>
</ul>
<p>P113</p>
<h2 id="quaternions"><a class="header" href="#quaternions">Quaternions</a></h2>
<p>P116</p>
<h3 id="定义-2"><a class="header" href="#定义-2">定义</a></h3>
<ul>
<li>
<p>Extending complex numbers<br />
$$
q =a+bi +cj +dk \in \mathbb{H} ,a,b,c,d\in \mathbb{R}
$$</p>
</li>
<li>
<p>\(i^2=j^2=k^2=ijk=-1\)</p>
</li>
<li>
<p>\(ij=k,ji=-k(^*\text{cross product})\)</p>
</li>
<li>
<p>\(jk=i,kj=-i\)</p>
</li>
<li>
<p>\(ki=j,ik=-j\)</p>
</li>
</ul>
<p>$$
q=w+xi+yj+zk \quad \Rightarrow  \quad  q=\begin{bmatrix}
w\\
x\\
y\\
z
\end{bmatrix}=\begin{bmatrix}
w\\
v
\end{bmatrix}
$$</p>
<p>$$
q =[w,v]^T \in \mathbb{H} ,w\in \mathbb{R},v\in \mathbb{R}^3
$$</p>
<p>$$
w =[w,0]^T : \text{ scalar quaternion }
$$</p>
<p>$$
v =[0,v]^T : \text{ pure quaternion }
$$</p>
<p>P117</p>
<h3 id="quaternion-arithmetic"><a class="header" href="#quaternion-arithmetic">Quaternion Arithmetic</a></h3>
<p>$$
q =a+bi +cj +dk \in \mathbb{H} ,a,b,c,d\in \mathbb{R}
$$</p>
<p>Conjugation:   \(\quad \quad q^*=a-bi-cj-dk\)<br />
\(<br>\)<br />
Scalar product:  \(\quad \quad tq=ta+tbi+tcj+tdk\)<br />
\(<br>\)<br />
Addition:  \(\quad \quad q_1+q_2=(a_1+a_2)+(b_1+b_2)i+(c_1+c_2)j+(d_1+d_2)k\)<br />
\(<br>\)<br />
Dot product:  \(\quad \quad q_1\cdot q_2=a_1a_2+b_1b_2+c_1c_2+d_1d_2\)<br />
\(<br>\)<br />
Norm:  \(\quad \quad ||q||=\sqrt{a^2+b^2+c^2+d^2} =\sqrt{q\cdot q}\)</p>
<p>P118</p>
<h3 id="quaternion-multiplication"><a class="header" href="#quaternion-multiplication">Quaternion Multiplication</a></h3>
<p>$$
q_1q_2=(a_1+b_1i+c_1j+d_1k)*(a_2+b_2i+c_2j+d_2k)
$$</p>
<p>$$
q_1q_2=a_1a_2-b_1b_2-c_1c_2-d_1d_2
$$</p>
<p>$$
+(b_1a_2+a_1b_2-d_1c_2+c_1d_2)i<br />
$$</p>
<p>$$
+(c_1a_2+d_1b_2+a_1c_2-b_1d_2)j<br />
$$</p>
<p>$$
+(d_1a_2-c_1b_2+b_1c_2+a_1d_2)k
$$</p>
<p>note:</p>
<ul>
<li>\(i^2=j^2=k^2=ijk=-1\)</li>
<li>\(ij=k,ji=-k (^* \text{cross product})\)</li>
<li>\(jk=i,kj=-i\)</li>
<li>\(ki=j,ik=-j\)</li>
</ul>
<blockquote>
<p>✅ \(q_1 \cdot q_2\) 和 \(q_1q_2\) 是两种不同的运算。</p>
</blockquote>
<p>P120</p>
<p>Conjugation:   \(\quad \quad q^*=[w,-v]^T\)<br />
\(<br>\)<br />
Scalar product:  \(\quad \quad tq=[tw,tv]^T\)<br />
\(<br>\)<br />
Addition:  \(\quad \quad q_1+q_2=[w_1+w_2,v_1+v_2]^T\)<br />
\(<br>\)<br />
Dot product:  \(\quad \quad q_1\cdot q_2=w_1w_2+v_1 \cdot v_2\)<br />
\(<br>\)<br />
Norm:  \(\quad \quad ||q||=\sqrt{w_1w_2+v_1 \cdot v_2} =\sqrt{q\cdot q}\)</p>
<p>P122</p>
<p>$$
q_1q_2=\begin{bmatrix}
w_1\\
v_1
\end{bmatrix}\begin{bmatrix}
w_2 \\
v_2
\end{bmatrix}=\begin{bmatrix}
w_1w_2-v_1\cdot v_2\\
w_1v_2+w_2v_1+v_1\times v_2
\end{bmatrix}
$$</p>
<p>Non-Commutativity: </p>
<p>$$
q_1q_2\ne q_2q_1
$$</p>
<p>Associativity:</p>
<p>$$
q_1q_2q_3=(q_1q_2)q_3=q_1(q_2q_3)
$$</p>
<p>P123</p>
<p>Conjugation:</p>
<p>$$
(q_1q_2)^\ast=q^\ast_2q^\ast_1
$$</p>
<p>Norm:</p>
<p>$$
||q||^2 = q^ \ast q =qq^\ast
$$</p>
<p>Reciprocal:</p>
<p>$$
\begin{matrix}
qq^{-1}=1  &amp; \Rightarrow &amp; q^{-1}=\frac{q^*}{||q||^2}\\
q^{-1}q=1  &amp;  &amp;
\end{matrix}
$$</p>
<p>P124</p>
<h3 id="unit-quaternions"><a class="header" href="#unit-quaternions">Unit Quaternions</a></h3>
<p>$$
\begin{matrix}
q=\begin{bmatrix}
w\\
v
\end{bmatrix} &amp;||q||=1
\end{matrix}
$$</p>
<p>For any non-zero quaternion \(\tilde{q} \):</p>
<p>$$
q=\frac{\tilde{q}}{||\tilde{q}||}
$$</p>
<p>Reciprocal:</p>
<p>$$
\begin{matrix}
q^{-1}=q^\ast =\begin{bmatrix}
w\\
-v
\end{bmatrix} &amp;\Leftrightarrow &amp; R^{-1}=R^T
\end{matrix}
$$</p>
<p>P125</p>
<table><thead><tr><th>2D</th><th>3D</th></tr></thead><tbody>
<tr><td><img src="./assets/02-26.png" alt="" /></td><td><img src="./assets/02-27.png" alt="" /></td></tr>
<tr><td>unit complex number</td><td>unit quaternion<br> ✅ 所有单位四元数构成 4D 空间上的单位球核。</td></tr>
<tr><td>\(z = \cos \theta  + i\sin \theta\)</td><td>\(q =  \begin{bmatrix} w\\v\end{bmatrix}= [\cos \frac{\theta}{2} ,   u\sin \frac{\theta}{2}] \quad \mid\mid u \mid\mid = 1\)</td></tr>
</tbody></table>
<p>same information as axis angles \((u,\theta)\) But in a different form</p>
<p>P127</p>
<h3 id="轴角表示---四元数表示"><a class="header" href="#轴角表示---四元数表示">轴角表示 -&gt; 四元数表示</a></h3>
<p>Any 3D rotation \((v,\theta)\) can be represented as a <strong>unit quaternion</strong></p>
<p>$$
\begin{matrix}
\text{Angle}: &amp; \theta =2 \text{ arg } \cos w\\
\text{ Axis}:  &amp; u=\frac{v}{||v||} 
\end{matrix}
$$</p>
<p>P128</p>
<h3 id="rotation-a-vector-using-unit-quaternions"><a class="header" href="#rotation-a-vector-using-unit-quaternions">Rotation a Vector Using Unit Quaternions</a></h3>
<p>已经向量p和单位四元数q，求p经过q旋转后的向量。</p>
<p><img src="./assets/02-29.png" alt="" /></p>
<p>$$
\begin{matrix}
\text{Unit quaternion}: &amp; q=\begin{bmatrix}
w\\
v
\end{bmatrix}=[\cos \frac{\theta }{2} ,u\sin \frac{\theta }{2}]\\
\text{ 3D vector}:p  &amp; \text{ Rotation result }: {p}'
\end{matrix}
$$</p>
<p>Then the rotation can be applied by <strong>quaternion multiplication</strong>:</p>
<blockquote>
<p>✅ 纯方向 \(p\) 可用四元数表示为 \([0 \quad p ]\)<br />
✅  \({p}' = R (q) \cdot p\)</p>
</blockquote>
<p>P129</p>
<p>$$
\begin{bmatrix}
0 \\
{p}' 
\end{bmatrix}=q\begin{bmatrix}
0\\
p
\end{bmatrix}q^\ast =(-q)\begin{bmatrix}
0\\
p
\end{bmatrix}(-q)^\ast 
$$</p>
<p>\(\mathbf{q}\) <strong>and</strong> \(−\mathbf{q}\) <strong>represent the same rotation</strong></p>
<p>P131</p>
<h3 id="combination-of-rotations-1"><a class="header" href="#combination-of-rotations-1">Combination of Rotations</a></h3>
<p>证明过程跳过，结论：</p>
<p>$$
\begin{matrix}
\text{Combined rotation}: &amp; q=q_2q_1
\end{matrix}
$$</p>
<p>P133</p>
<h3 id="quaternion-interpolation"><a class="header" href="#quaternion-interpolation">Quaternion Interpolation</a></h3>
<p><img src="./assets/02-31.png" alt="" /></p>
<p>A unit hypersphere in 4D space</p>
<blockquote>
<p>✅ 单位四元数表现出来是 4D 空间中的球核，\(q_1q_2\) 是球核上的两个点，希望沿球面轨迹插值。</p>
</blockquote>
<p>P135</p>
<h4 id="linear-interpolation"><a class="header" href="#linear-interpolation">Linear Interpolation</a></h4>
<p>$$
q_t=(1-t)q_0+tq_1
$$</p>
<p><img src="./assets/02-32.png" alt="" /></p>
<p>\(q_t\) is not a unit quaternion</p>
<p>P136</p>
<h4 id="linear-interpolation--projection"><a class="header" href="#linear-interpolation--projection">Linear Interpolation + Projection</a></h4>
<p>$$
\begin{matrix}
\tilde{q}_t=(1-t)q_0+tq_1  &amp; q_t=\frac{\tilde{q}_t }{||\tilde{q}_t||} 
\end{matrix}
$$</p>
<p><img src="./assets/02-33.png" alt="" /></p>
<p>$$
\begin{matrix}
q_t \text{ is a unit quaternion}\\
\text{Rotational speed is not constant}
\end{matrix}
$$</p>
<blockquote>
<p>✅ 当 \(u_0＝-u_1\) 时，可能得到某个 \(\tilde{q} _t = 0\)，无法单位化<br />
✅ 解决方法:根据 \(u_0＝-u_0\)，先找到 \(u_0\) 和 \(u_1\) 在数值上最接近的四元数表示。</p>
</blockquote>
<p>P137</p>
<h4 id="slerp-spherical-linear-interpolation"><a class="header" href="#slerp-spherical-linear-interpolation">SLERP: Spherical Linear Interpolation</a></h4>
<h5 id="思考"><a class="header" href="#思考">思考</a></h5>
<p>$$
q_t=a(t)q_0+b(t)q_1
$$</p>
<p>如何设计a和b，让插值结果速度恒定？</p>
<p><img src="./assets/02-34.png" alt="" /></p>
<p>$$
r=a(t)p+b(t)q
$$</p>
<h5 id="计算"><a class="header" href="#计算">计算</a></h5>
<p>Consider the angle \(\theta\) between \(p,q\):</p>
<p>$$
\cos \theta =p\cdot q
$$</p>
<p>We have:</p>
<p>$$
\begin{matrix}
p \cdot r=a(t)p\cdot p+b(t)q\cdot p\\
\Rightarrow \cos t \theta =a(t)+b(t)\cos \theta 
\end{matrix}
$$</p>
<p>similarly:</p>
<p>$$
\begin{matrix}
q \cdot r=a(t)q\cdot p+b(t)\\
\Rightarrow \cos (1- t) \theta =a(t)\cos\theta +b(t)<br />
\end{matrix}
$$</p>
<h5 id="结论-4"><a class="header" href="#结论-4">结论</a></h5>
<p>then we have：</p>
<p>$$
a(t)=\frac{\sin [(1-t)\theta ]}{\sin \theta  } ,b(t)=\frac{\sin t \theta }{\sin \theta } 
$$</p>
<p><img src="./assets/02-35.png" alt="" /></p>
<p>P139</p>
<p>$$
q_t=\frac{\sin [(1-t)\theta ]}{\sin \theta  }q_0+\frac{\sin t \theta }{\sin \theta }q_1 
$$</p>
<p>$$
\cos \theta=q_0\cdot  q_1
$$</p>
<p>P140</p>
<h3 id="结论-5"><a class="header" href="#结论-5">结论</a></h3>
<p>Rotations can be represented by <strong>unit quaternions</strong></p>
<p>Representation is not unique</p>
<p>\(q, −q\) represent the same rotation</p>
<ul>
<li>Easy to compose?   \(\quad \quad {\color{Green} \surd }\quad \quad \)     Need normalization, hard to manipulate,</li>
<li>Easy to apply?    \(\quad \quad  \quad {\color{Green} \surd }\quad \quad \)       Quaternion multiplication</li>
<li>Easy to interpolate?  \(\quad   {\color{Green} \surd }\quad \quad \)   SLERP, need to deal with singularities</li>
<li>No Gimbal lock  \(\quad \quad  \quad {\color{Green} \surd }\quad \quad \)</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="outline-1"><a class="header" href="#outline-1">Outline</a></h1>
<ul>
<li>
<p>Character Kinematics</p>
<ul>
<li>Skeleton and forward Kinematics</li>
</ul>
</li>
<li>
<p>Inverse Kinematics</p>
<ul>
<li>IK as a optimization problem</li>
<li>Optimization approaches
<ul>
<li>Cyclic Coordinate Descent (CCD)</li>
<li>Jacobian and gradient descent method</li>
<li>Jacobian inverse method</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>P4</p>
<h1 id="character-kinematics"><a class="header" href="#character-kinematics">Character Kinematics</a></h1>
<p>the study of the motion of bodies <strong>without reference to mass or force</strong></p>
<p>P8</p>
<h2 id="joint-bone-skeleton"><a class="header" href="#joint-bone-skeleton">joint, bone, skeleton</a></h2>
<p><img src="./assets/03-01.png" alt="" /><br />
<img src="./assets/03-02.png" alt="" /></p>
<blockquote>
<p>✅ 关注关节的位置和旋转</p>
</blockquote>
<p>P13</p>
<h2 id="kinematics-of-a-chain"><a class="header" href="#kinematics-of-a-chain">Kinematics of a Chain</a></h2>
<h3 id="问题描述-3"><a class="header" href="#问题描述-3">问题描述</a></h3>
<p>要使手臂摆成指定的动作，每个关节在各自坐标系下的旋转是多少？</p>
<p><img src="./assets/03-03-1.png" alt="" /></p>
<p>求\(Q_0, Q_1, Q_2, Q_3, Q_4\)</p>
<p>P14</p>
<h3 id="初始pose"><a class="header" href="#初始pose">初始pose</a></h3>
<p><img src="./assets/03-03.png" alt="" /></p>
<p>$$
Q_0=Q_1=Q_2=Q_3=Q_4=I
$$</p>
<blockquote>
<p>✅ 这一个定义了5个关节的手臂。在每个关节上绑上一个坐标系。 </p>
</blockquote>
<p>P15</p>
<h3 id="旋转关节4"><a class="header" href="#旋转关节4">旋转关节4</a></h3>
<p>把关节4旋转R4以后</p>
<p><img src="./assets/03-04.png" alt="" /></p>
<blockquote>
<p>✅ \(Q\)：在世界坐标系下的朝向<br />
✅ \(R\)：在局部坐标系下的旋转</p>
</blockquote>
<p>$$
\begin{matrix}
Q_0=I\quad\\<br />
Q_1=I\quad\\<br />
Q_2=I\quad\\<br />
Q_3=I\quad\\<br />
Q_4={\color{Red}{R_4}}
\end{matrix}
$$</p>
<p>P16</p>
<h3 id="旋转关节3"><a class="header" href="#旋转关节3">旋转关节3</a></h3>
<p><img src="./assets/03-05.png" alt="" /> </p>
<p>把关节3旋转R3以后，Q3和Q4会同时受到影响</p>
<p>$$
\begin{matrix}
Q_0=I\quad\quad\\<br />
Q_1=I\quad\quad\\<br />
Q_2=I\quad\quad\\<br />
Q_3={\color{Red}{R_3}}\quad\\<br />
Q_4={\color{Red}{R_3}}R_4
\end{matrix}
$$</p>
<p>P17</p>
<h3 id="依次旋转关节2-1-0"><a class="header" href="#依次旋转关节2-1-0">依次旋转关节2， 1， 0</a></h3>
<p><img src="./assets/03-08.png" alt="" /></p>
<p>$$
\begin{matrix}
Q_0={\color{Red}{R_0}}\quad \quad\quad\quad \\
Q_1={\color{Red}{R_0}}R_1 \quad\quad\quad \\
Q_3={\color{Red}{R_0}}R_1R_2R_3\quad \\
Q_4={\color{Red}{R_0}}R_1R_2R_3R_4
\end{matrix}
$$</p>
<p>P20</p>
<h3 id="简化公式用递推的形式描述"><a class="header" href="#简化公式用递推的形式描述">简化公式，用递推的形式描述</a></h3>
<p><img src="./assets/03-09-1.png" alt="" /></p>
<p>P21</p>
<p>From rotation(local) to orientation(global)</p>
<p>$$
Q_i = Q_{i-1}R_i
$$</p>
<p>From orientation(global) to rotation(local)</p>
<p>$$
R_i = Q^T_{i-1}Q_i
$$</p>
<blockquote>
<p>✅ 这些 \(Q\) 都是全局旋转，\(R\) 是局部旋转。</p>
</blockquote>
<h2 id="kinematics-with-position"><a class="header" href="#kinematics-with-position">Kinematics with position</a></h2>
<p>P23</p>
<h3 id="初始状态"><a class="header" href="#初始状态">初始状态</a></h3>
<p><img src="./assets/03-11.png" alt="" /></p>
<blockquote>
<p>✅ \( 𝒍 \)：子关节位置在父坐标系下的坐标。</p>
</blockquote>
<p>P31</p>
<h3 id="positon-with-pose"><a class="header" href="#positon-with-pose">positon with pose</a></h3>
<p><img src="./assets/03-011.png" alt="" /></p>
<blockquote>
<p>✅ \(p\) 是全局位置，\( 𝒍 \) 是局部偏移。</p>
</blockquote>
<p>P37</p>
<h2 id="forward-kinematics-of-a-chain-summary"><a class="header" href="#forward-kinematics-of-a-chain-summary">Forward Kinematics of a Chain: Summary</a></h2>
<h3 id="position"><a class="header" href="#position">position</a></h3>
<p>Given the rotations of all joints \(R_i\), find the coordinates of \(x_0\) in the global frame \(x\):</p>
<p><img src="./assets/03-14.png" alt="" /></p>
<blockquote>
<p>✅ \(x_0\) 是 \(R_4\) 坐标系下的点，求它在某个父坐标系下的位置。<br />
✅ \(p\)：关节在全局坐标系下的位置<br />
✅ 第1步：根据 \(R_i\) 和 \( 𝒍 _i\) 求出 \(Q_i\) 和 \(P_i\)<br />
✅ 第2步：\(E\) 可以是任意父结点，公式都适用</p>
</blockquote>
<p>P38</p>
<p><img src="./assets/03-15.png" alt="" /></p>
<blockquote>
<p>✅ 是上一页的另一种写法，不需提前算出中间变量。</p>
</blockquote>
<p>P39</p>
<h3 id="rotation-1"><a class="header" href="#rotation-1">rotation</a></h3>
<p>Given the rotations of all joints \(R_i\), find the coordinates of \(x_0\) relative to the local frame of \(Q_k\):</p>
<p><img src="./assets/03-16.png" alt="" /></p>
<blockquote>
<p>✅ 已知全局坐标系下的坐标，求 \(Q_k\) 下的坐标。</p>
</blockquote>
<p>P40</p>
<p><img src="./assets/03-17.png" alt="" /></p>
<blockquote>
<p>✅ 对应上一页的另一种写法</p>
</blockquote>
<p>P41</p>
<h2 id="kinematics-of-a-character"><a class="header" href="#kinematics-of-a-character">Kinematics of a Character</a></h2>
<h3 id="骨骼的参数化表示"><a class="header" href="#骨骼的参数化表示">骨骼的参数化表示</a></h3>
<p><img src="./assets/03-18.png" alt="" /></p>
<blockquote>
<p>✅ 把角色建模成多条关节链。</p>
</blockquote>
<p>P43</p>
<p><img src="./assets/03-18-1.png" alt="" /></p>
<blockquote>
<p>✅ 以不同关节为 root，同样旋转会得到不同效果。</p>
</blockquote>
<p>P45</p>
<h3 id="types-of-joints"><a class="header" href="#types-of-joints">Types of Joints</a></h3>
<p><img src="./assets/03-20.png" alt="" /></p>
<p>P50</p>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/03-025-2.png" alt="" /></td><td><img src="./assets/03-023.png" alt="" /></td><td>knee, elbow <br>  \({\color{Red}{1 \text{DoF}}}\)  <br> \(\theta_{\min }\le \theta\le  \theta_{\max } \) <br> hinge joint <br>  revolute joint</td></tr>
<tr><td><img src="./assets/03-025-1.png" alt="" /></td><td><img src="./assets/03-024.png" alt="" /></td><td>hip, shoulder <br>  \({\color{Red}{3 \text{DoF}}}\) <br> \(\theta_{\min }\preceq  \theta \preceq  \theta_{\max } \) <br> ball-and-socket joint</td></tr>
<tr><td></td><td><img src="./assets/03-25.png" alt="" /></td><td>手腕。其实手腕不能自转。<br>2 Dof</td></tr>
</tbody></table>
<blockquote>
<p>✅ 关节的自由度最多为3，因为不能自主移动。Hips 除外。
✅ 自由度：一个物理系统，需要多少参数可以唯一准确地描述它的状态。<br />
✅ 6 DOF＝3 平移 ＋ 3 旋转。</p>
</blockquote>
<h3 id="姿态的参数化表示-pose-parameters"><a class="header" href="#姿态的参数化表示-pose-parameters">姿态的参数化表示 Pose Parameters</a></h3>
<p>P55</p>
<p>$$
(t_0,R_0,R_1,R_2\dots \dots ) 
$$</p>
<p>$$
\text{root } \mid \text{ internal joints}
$$</p>
<p>joints are typically in the order that every joint precedes its offspring</p>
<p>for \(i\) in joint_list:</p>
<p>$$
\begin{align*}
p_i= &amp; i^,\text{ s parent joint} \\
Q_i=&amp; Q_{pi}R_i \\
x_i= &amp; x_{pi} + Q_{pi}l_i
\end{align*}
$$</p>
<blockquote>
<p>✅ 一个动作的参数化表示：<br />
✅ 全局位置＋root 朝向＋各关节旋转<br />
✅ 通常要求，关节顺序为父在前子在后，这样只须遍历一遍就能完成 FK.</p>
</blockquote>
<blockquote>
<p>❓ Q2: how should we allow stretchable bones?<br />
✅ 答：增加参数，3 Dof 增加为 6 Dof.</p>
</blockquote>
<p>P58</p>
<h3 id="example-motion-data-in-a-file"><a class="header" href="#example-motion-data-in-a-file">Example: motion data in a file</a></h3>
<p>BVH files</p>
<ul>
<li>HIERARCHY: defining <strong>T-pose of</strong> the character</li>
<li>MOTION: root position and <strong>Euler angles</strong> of each joints</li>
</ul>
<p>See: <a href="https://research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/BVH.html">https://research.cs.wisc.edu/graphics/Courses/cs-838-1999/Jeff/BVH.html</a></p>
<p><img src="./assets/03-30-1.png" alt="" /></p>
<p><img src="./assets/03-31-1.png" alt="" /></p>
<p>P59</p>
<h1 id="inverse-kinematics-1"><a class="header" href="#inverse-kinematics-1">Inverse Kinematics</a></h1>
<blockquote>
<p>🔎 A. Aristidou, J. Lasenby, Y. Chrysanthou, and A. Shamir. 2018.<br />
<strong>Inverse Kinematics Techniques in Computer Graphics: A Survey.</strong><br />
Computer Graphics Forum</p>
</blockquote>
<p>P61</p>
<h2 id="forward-and-inverse-problems"><a class="header" href="#forward-and-inverse-problems">Forward and Inverse Problems</a></h2>
<p>For a system that can be described by a set of <strong>parameters</strong> \(\theta \), and a <strong>property</strong> 𝒙 of the system given by</p>
<p>$$
x=f(\theta )
$$</p>
<p><strong>Forward problem</strong>:</p>
<ul>
<li>
<p>Given \(\theta \), we need to compute \(x \)</p>
</li>
<li>
<p>Easy to compute since \(f\) is known, the result is unique</p>
</li>
<li>
<p>DoF of \( \theta \) is often much larger than that of \(x \). We cannot easily tune \(\theta \) to achieve a specific value of \(x\). </p>
</li>
</ul>
<p><strong>Inverse problem</strong>:</p>
<ul>
<li>
<p>Given \(x \), we need to find a set of valid parameters \(\theta \) such that\(x=f(\theta) \)</p>
</li>
<li>
<p>Often need to solve a difficult <strong>nonlinear</strong> equation, which can have <strong>multiple</strong> solutions</p>
</li>
<li>
<p>\(x\) is typically meaningful and can be set in intuitive ways</p>
</li>
</ul>
<p>P62</p>
<h2 id="inverse-kinematics问题描述"><a class="header" href="#inverse-kinematics问题描述">Inverse Kinematics问题描述</a></h2>
<p><img src="./assets/03-32.png" alt="" /></p>
<p>Given the position of the end-effector \(x\), Compute the joint rotations \(R_i\)</p>
<p>P64</p>
<blockquote>
<p>✅ 大部分情况下IK问题是多解问题</p>
</blockquote>
<p><img src="./assets/03-33.png" alt="" /></p>
<p>P68</p>
<h2 id="two-joint-ik"><a class="header" href="#two-joint-ik">two-joint IK</a></h2>
<h3 id="step-1-rotate-joint-1-such-that"><a class="header" href="#step-1-rotate-joint-1-such-that">Step 1: Rotate joint 1 such that</a></h3>
<p><img src="./assets/03-35.png" alt="" /></p>
<p>$$
||l_{ox}||=||l_{02}||
$$</p>
<blockquote>
<p>✅ 使用余弦公式</p>
</blockquote>
<h3 id="step-2-rotate-joint-0-such-that"><a class="header" href="#step-2-rotate-joint-0-such-that">Step 2: Rotate joint 0 such that</a></h3>
<p><img src="./assets/03-36.png" alt="" /></p>
<p>$$
l_{ox}=l_{02}
$$</p>
<blockquote>
<p>✅ 叉乘得到旋轴，点乘得到旋转角。</p>
</blockquote>
<h3 id="step-3-rotate-joint-0-around-l_ox-if-necessary"><a class="header" href="#step-3-rotate-joint-0-around-l_ox-if-necessary">Step 3: Rotate joint 0 around \(l_{ox}\) if necessary</a></h3>
<p><img src="./assets/03-37.png" alt="" /></p>
<h2 id="multi-joint-ik"><a class="header" href="#multi-joint-ik">Multi Joint IK</a></h2>
<p>P72</p>
<p>机械臂场景，关节有多个，指定末端结点的位置和朝向</p>
<p>$$
x=f(\theta ) \\
Q=Q(\theta )
$$</p>
<p><img src="./assets/03-38.png" alt="" /></p>
<blockquote>
<p>✅ 控制末端点的朝向比较简单，但控制末端点的位置比较难，因此重点考虑如何控制末端点的位置</p>
</blockquote>
<p>P74</p>
<h3 id="ik-as-an-optimization-problem"><a class="header" href="#ik-as-an-optimization-problem">IK as an Optimization Problem</a></h3>
<p><img src="./assets/03-39-1.png" alt="" /></p>
<p>P75</p>
<p>Find \(\theta \)  to optimize</p>
<p>$$
\min_{\theta } \frac{1}{2} ||f(\theta )-\tilde{x} ||^2_2
$$</p>
<blockquote>
<p>✅ 用迭代的方法，从当前 motion 出发，优化出目标 motion.</p>
</blockquote>
<p>P88</p>
<h3 id="ccdik"><a class="header" href="#ccdik">CCDIK</a></h3>
<h4 id="cyclic-coordinate-descent-ccd"><a class="header" href="#cyclic-coordinate-descent-ccd">Cyclic Coordinate Descent (CCD)</a></h4>
<p>Update parameters along each axis of the coordinate system</p>
<p>Iterate cyclically through all axes</p>
<p><img src="./assets/03-40.png" alt="" /></p>
<p>P90</p>
<h4 id="cyclic-coordinate-descent-ccd-ik"><a class="header" href="#cyclic-coordinate-descent-ccd-ik">Cyclic Coordinate Descent (CCD) IK</a></h4>
<blockquote>
<p>✅ 叉乘得到旋转轴，点乘得到旋转角度。</p>
</blockquote>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Rotate joint 3 such that \(𝒍_{34}\) points towards \(\tilde{x}\)</td><td><img src="./assets/03-41.png" alt="" /></td></tr>
<tr><td>Rotate joint 2 such that \(𝒍_{24}\) points towards \(\tilde{x}\)</td><td><img src="./assets/03-43.png" alt="" /></td></tr>
<tr><td>Rotate joint 1 such that \(𝒍_{14}\) points towards \(\tilde{x}\)</td><td><img src="./assets/03-44.png" alt="" /></td></tr>
<tr><td>Rotate joint 0 such that \(𝒍_{14}\) points towards \(\tilde{x}\)</td><td><img src="./assets/03-45.png" alt="" /></td></tr>
<tr><td>Rotate joint 3 such that \({l}'_{34}\) points towards \(\tilde{x}\)</td><td><img src="./assets/03-46.png" alt="" /></td></tr>
<tr><td>……</td><td></td></tr>
</tbody></table>
<p>Iteratively rotation each joint to make the end-effector align with vector between the joint and the target</p>
<p>Easy to implement, very fast</p>
<p>The “first” joint moves more than the others May take <strong>many iterations</strong> to <strong>converge</strong> Result can be sensitive to the <strong>initial solution</strong></p>
<blockquote>
<p>✅ 一个动作序列做 CCD，可能结果不稳定，有跳变。<br />
✅ 前面例子是 3210 的调整顺序，也可以是 0123 的顺序。<br />
✅ 先移到的关节调整幅度会大一点，所以一般从末端开始。</p>
</blockquote>
<p>P105</p>
<h2 id="gradient-descent"><a class="header" href="#gradient-descent">Gradient Descent</a></h2>
<p>CCD下降没有考虑目标函数的性质，考虑目标函数的性质可以得出下降更快的方法。</p>
<blockquote>
<p>✅ 关于梯度下降法跳过。</p>
</blockquote>
<p>针对目标函数</p>
<p>$$
\min_{\theta } \frac{1}{2} ||f(\theta )-\tilde{x} ||^2_2
$$</p>
<p>其梯度为：</p>
<p>$$
\begin{align*}
\nabla_\theta F(\theta ^i)= &amp; (\frac{\partial f}{\partial \theta }(\theta ^i))^T(f(\theta ^i)-\tilde{x})\\
= &amp; J^T \Delta<br />
\end{align*}
$$</p>
<blockquote>
<p>✅ \(J\) 是 Jacobia矩阵， \( \Delta \) 是位置差</p>
</blockquote>
<p>P106</p>
<p>因为更新函数为：</p>
<p>$$
\theta ^{i+1}=\theta ^i-\alpha J^T\Delta
$$</p>
<p>$$
J= \frac{\partial f}{\partial \theta }=(\frac{\partial f}{\partial \theta_0 }\frac{\partial f}{\partial \theta_1 }\dots \frac{\partial f}{\partial \theta_n } ) 
$$</p>
<p>J是一个3*N的矩阵，N代表关节数。<br />
<img src="./assets/03-46-2.png" alt="" /></p>
<p>怎么计算J？<br />
方法一：使用machine learning framework的autograd功能<br />
方法二：有限差分<br />
方法三：Geometric Approach</p>
<p>P114</p>
<h3 id="geometric-approach"><a class="header" href="#geometric-approach">Geometric Approach</a></h3>
<h4 id="问题描述-4"><a class="header" href="#问题描述-4">问题描述</a></h4>
<p><em>Assuming all joints are hinge joint</em><br />
求关节 1 旋转轴 \(a_1\)，对 \(x\) 位移的影响</p>
<p><img src="./assets/03-46-1.png" alt="" /></p>
<h4 id="计算过程-1"><a class="header" href="#计算过程-1">计算过程</a></h4>
<p>$$
{x}' -x=(\sin \delta \theta _i)a_i\times r_i+(1-\cos \delta \theta _i)a_i\times(a_i\times r_i)
$$</p>
<p>$$
\frac{ \partial f }{\partial \theta _ i} = \lim _ {\delta \theta _ i \to 0} \frac{{x}'-x }{\delta \theta _ i}= a _ i\times r _i 
$$</p>
<p>P117</p>
<h4 id="更通用的场景--ball-joints"><a class="header" href="#更通用的场景--ball-joints">更通用的场景- ball joints</a></h4>
<p>❓ How to deal with ball joints?<br />
A ball joint parameterized as Euler angles:</p>
<p>$$ 
𝑅_𝑖 = 𝑅_{𝑖𝑥}𝑅_{𝑖𝑦}𝑅_{𝑖𝑧}
$$</p>
<p>can be considered as a compound joint with 
three hinge joints</p>
<p><img src="./assets/03-46-4.png" alt="" /></p>
<blockquote>
<p>✅ 一个ball joint可以看作是3个hint joint。因此占J矩阵的3列。</p>
</blockquote>
<p>也可以写成这种形式：</p>
<p>$$
\frac{ \partial f }{\partial \theta _ {i\ast } } = a _ {i\ast } \times r _ i
$$</p>
<p>f对某一个欧拉角的导数，等于这个欧拉角的轴叉乘上末端点到关节点的距离。</p>
<p>需要注意的是，这个的旋转轴a是在世界坐标系下的表示，因此要有一个坐标系的转换。</p>
<p>$$
\begin{align*}
𝒂_{𝑖𝑥} &amp; =𝑄_{𝑖−1}𝒆_𝑥  \\
𝒂_{𝑖𝑦}&amp; = 𝑄_{𝑖−1}𝑅_{𝑖𝑥}𝒆_𝑦\\
𝒂_{𝑖𝑧} &amp;= 𝑄_{𝑖−1}𝑅_{𝑖𝑥}𝑅_{𝑖𝑦}𝒆_𝑧
\end{align*}
$$</p>
<blockquote>
<p>❓ 问：Can we parameterize a ball joint using axis-angle \(\theta u\) and compute Jacobian as</p>
</blockquote>
<p>$$
\begin{matrix}
\frac{\partial f}{\partial \theta _i} =\theta u\times r_i &amp; ???
\end{matrix}
$$</p>
<blockquote>
<p>✅ 答：不可以。Jacobian for axis-angle representation has a rather complicated formulation…</p>
</blockquote>
<p>P121</p>
<h4 id="jacobian-transpose--gradient-descent"><a class="header" href="#jacobian-transpose--gradient-descent">Jacobian Transpose / Gradient Descent</a></h4>
<p>First-order approach, convergence can be slow Need to re-compute Jacobian at each iteration</p>
<blockquote>
<p>✅ 怎么求 \(J\)，这里讲了 3 种方法：（1）backward 框架（2）差分（3）几何计算。实际上直接用 1 可以解决，不需要自己去算，因此跳过。<br />
✅ 特点：（1）迭代次数比 CCD 少（2）计算量比 CCD 大。</p>
</blockquote>
<p>P122</p>
<blockquote>
<p>✅ 数值插值算法见 GAMES102.</p>
</blockquote>
<p>P124</p>
<h2 id="quadratic-programming-二次规划问题"><a class="header" href="#quadratic-programming-二次规划问题">Quadratic Programming 二次规划问题</a></h2>
<blockquote>
<p>✅ 这几页介绍二次函数求极值的问题。</p>
</blockquote>
<p>$$
\min_{\theta } F(\theta )=\frac{1}{2} \theta ^TA\theta +b^T\theta 
$$</p>
<p>where \(A\) is positive definite:</p>
<p>$$
A=A^T,\theta ^TA\theta \ge 0 \text{ for any } \theta 
$$</p>
<p>P126</p>
<h3 id="公式直接求解"><a class="header" href="#公式直接求解">公式直接求解</a></h3>
<p>$$
\begin{matrix}
\text{Gradient}: \nabla_\theta  F(\theta )=A\theta +b \\
\text{Optimality condition}: \nabla_\theta  F(\theta ^\ast )=0\\
{\color{Blue} \Downarrow } \\
\theta ^\ast =-A^{-1}b
\end{matrix}
$$</p>
<blockquote>
<p>✅ 二次函数的极值点可以直接从公式求出来</p>
</blockquote>
<p>P127</p>
<h3 id="gauss-newton-method"><a class="header" href="#gauss-newton-method">Gauss-Newton Method</a></h3>
<blockquote>
<p>✅ IK问题也可以转化为二次函数求极值的问题</p>
</blockquote>
<p>$$
F(\theta )=\frac{1}{2} ||f(\theta )-\tilde{x} ||^2_2
$$</p>
<p><img src="./assets/03-47.png" alt="" /></p>
<p>Consider the first-order approximation of \(f(\theta)\) at \(\theta^0\)</p>
<blockquote>
<p>✅ 把 \(f(\theta )\) 在 \(\theta ^{\circ} \) 处一阶泰勒展开。</p>
</blockquote>
<p>$$
\begin{align*}
f(\theta)\approx &amp; f(\theta^0) + \frac{\partial f}{\partial \theta} (\theta^0)(\theta-\theta^0) \\
= &amp; f(\theta^0)+J(\theta-\theta^0)
\end{align*}
$$</p>
<p>P128</p>
<blockquote>
<p>✅ 把它代入目标函数。</p>
</blockquote>
<p>\begin{align*}
f(\theta)\approx  &amp; \frac{1}{2}||f(\theta^0)+J(\theta -\theta ^0)-\tilde{x}||^2_2    \\
= &amp;\frac{1}{2} (\theta -\theta ^0)^TJ^TJ(\theta -\theta ^0)\\
&amp; +(\theta -\theta ^0)^TJ^T(f(\theta ^0)-\tilde{x})+c 
\end{align*}</p>
<p>P129</p>
<p>first-order optimality condition</p>
<blockquote>
<p>✅ 令 \((\nabla F (\theta ))^T=0\)</p>
</blockquote>
<p>$$
\begin{matrix}
f(\theta)\approx  \frac{1}{2}||f(\theta^0)+J(\theta -\theta ^0)-\tilde{x}||^2_2 \\
\Downarrow \\
(\nabla F (\theta ))^T=J^TJ(\theta-\theta^0)+J^T(f(\theta^0)-\tilde{x} )=0
\end{matrix}
$$</p>
<p>P133<br />
$$
J^TJ(\theta-\theta^0)=-J^T\Delta 
$$</p>
<h4 id="if-jtj-不可逆"><a class="header" href="#if-jtj-不可逆">if \(J^TJ\) 不可逆</a></h4>
<blockquote>
<p>✅ \(J\) 的维度是 \(3\times N\)，因此 \(J^TJ\) 不可逆。</p>
</blockquote>
<p>\(J^TJ\) is \({\color{Red} {\text{NOT}}}\) invertible, but \(JJ^T\) can be invertible</p>
<p>P134<br />
因此做以下转化：</p>
<p><img src="./assets/03-042.png" alt="" /></p>
<blockquote>
<p>✅ \(\Delta\) 是当前和目标的末端点位置之差。</p>
</blockquote>
<p>P135</p>
<p>$$
J(\theta-\theta^0)=\tilde{x} -f(\theta^0)
$$</p>
<p>P137</p>
<p>$$
\begin{align*}
\theta = &amp; \theta ^0-J^+\Delta \\
= &amp; \theta ^0-J^T(JJ^T)^{-1}\Delta
\end{align*}
$$</p>
<p>\(J^+\)表示J的(Moore-Penrose) Pseudoinverse</p>
<p>P138</p>
<h4 id="if-jtj-可逆"><a class="header" href="#if-jtj-可逆">if \(J^TJ\) 可逆</a></h4>
<p>$$
J^TJ(\theta-\theta^0)=-J^T\Delta 
$$</p>
<p>If \(J^TJ\) is invertible, we have</p>
<p>$$
\theta = \theta^0 - (J^TJ)^{-1}J^T\Delta
$$</p>
<p>but when can \(J^TJ\) be invertible?</p>
<p>P141</p>
<blockquote>
<p>✅ 答：改变IK的约束条件（例如增加中间关节的位置要求）和自由度（例如限制关节的自由度），可改变 \(J\) 的形状为方阵或高瘦阵，此时 \(J^TJ\) 可逆，则换一种方式求逆。</p>
</blockquote>
<p>P143</p>
<h4 id="对比"><a class="header" href="#对比">对比</a></h4>
<p><img src="./assets/03-50.png" alt="" /></p>
<blockquote>
<p>✅ 左：欠约束，右：过约束。<br />
✅ 由于这个方法的本质是把高度非线性的函数做了线性化，所以只是在当前位置附近才有效，远了误差就会非常大。因此增加learning rate。</p>
</blockquote>
<p>P145</p>
<p>Usually faster than gradient descent/Jacobian transpose method.</p>
<p>Any problem? \(JJ^T/J^TJ\) can be (near) singular!</p>
<blockquote>
<p>✅ 快一点是因为 \(J^＋\) 是近似的 \(J\)，计算量较小，问题是可能得到一个错很远的 \(J^＋\)，导致结果不稳定。</p>
</blockquote>
<p>P147</p>
<h3 id="damped-jacobian-inverse-method"><a class="header" href="#damped-jacobian-inverse-method">Damped Jacobian Inverse Method</a></h3>
<blockquote>
<p>✅ 上一页的问题是伪逆\(J^＋\) 引入的不稳定。<br />
✅ 解决方法：引 \(\lambda\) 阻尼项</p>
</blockquote>
<p>$$
J^\ast =J^T(JJ^T+\lambda I)^{-1}
$$</p>
<p>$$
J^\ast =(J^TJ+\lambda I)^{-1}J^T
$$</p>
<p>P148<br />
Also called Levenberg-Marquardt algorithm</p>
<blockquote>
<p>✅ 引 \(\lambda\) 阻尼顶后，两种方式的计算结果相同。<br />
✅ 当 \(\lambda\) 很大时，此方法等价于梯度下降法。</p>
</blockquote>
<p>P149</p>
<h4 id="lambda-的几何意义"><a class="header" href="#lambda-的几何意义">\(\lambda\) 的几何意义</a></h4>
<blockquote>
<p>✅ 相当于正则项
✅ 进一步地，分别给每个关节移动权重。<br />
✅ 权重越大，移动越小。</p>
</blockquote>
<p><img src="./assets/03-51.png" alt="" /></p>
<p>P152</p>
<h2 id="character-全身ik"><a class="header" href="#character-全身ik">Character 全身IK</a></h2>
<p><img src="./assets/03-052.png" alt="" /></p>
<blockquote>
<p>✅ 全身 IK，不同链条上都有目标点。<br />
✅ 可以同时优化所有链，或选一个或选一些。<br />
✅ IK 要更新哪关节也可以自由设定。</p>
</blockquote>
<p>P156</p>
<h1 id="总结-2"><a class="header" href="#总结-2">总结</a></h1>
<blockquote>
<p>✅ IK问题可以使用优化方法，不同优化方法对应不同 IK 方法，例如：<br />
CCD → CCDIK<br />
梯度下降法 → Jacobian transpose<br />
Gaussian → Jacobian Inverse<br />
✅ IK问题可以使用启发式方法，例如FABRIK
Andreas Aristidou and Joan Lasenby. 2011.<br />
🔎 <strong>FABRIK: A fast, iterative solver for the Inverse Kinematics problem.</strong><br />
<em>Graphical Models</em></p>
</blockquote>
<p>P158</p>
<blockquote>
<p>✅ Slerp 结合 Sbline.<br />
✅ 50 fps → 60 fps：先插值，再采样<br />
✅ 惯性插值：UE 基于 SPD 求约束来做 IK<br />
✅ 参考 Darel Holden 博客</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="outline-2"><a class="header" href="#outline-2">Outline</a></h1>
<ul>
<li>
<p>Character Kinematics (cont.)</p>
<ul>
<li>Motion Retargeting</li>
<li>Full-body IK</li>
</ul>
</li>
<li>
<p>Keyframe Animation</p>
<ul>
<li>Interpolation and splines</li>
</ul>
</li>
</ul>
<p>P4</p>
<h2 id="recap-character-kinematics"><a class="header" href="#recap-character-kinematics">Recap: Character Kinematics</a></h2>
<p><img src="./assets/04-01.png" alt="" /></p>
<p>P15</p>
<h1 id="reference-pose"><a class="header" href="#reference-pose">Reference Pose</a></h1>
<p>{ \(𝑅_𝑖 = 𝐼\) }<br />
The pose with zero / identity rotation Bind pose / Reference pose</p>
<blockquote>
<p>❗ reference pose不一定是Tpose。</p>
</blockquote>
<p>P16</p>
<h2 id="t-pose-a-pose"><a class="header" href="#t-pose-a-pose">T-Pose? A-Pose?</a></h2>
<p><img src="./assets/04-04.png" alt="" /></p>
<p><img src="./assets/04-05.png" alt="" /></p>
<blockquote>
<p>✅ 常见的reference pose一般为Apose或者Tpose。<br />
✅ 对于骨骼动画来讲，\(A\) 或 \(T\) 都一样。<br />
✅ 对于骼骼绑定与蒙皮来讲，更倾向于\(A\)。因为 \(A\) 的肩膀是自然状态。</p>
</blockquote>
<p>P19</p>
<h2 id="特殊的reference-pose"><a class="header" href="#特殊的reference-pose">特殊的reference pose</a></h2>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/04-06.png" alt="" /></td><td><img src="./assets/04-07.png" alt="" /></td><td><img src="./assets/04-08.png" alt="" /> <br> ✅ 这个动作跟建模师建模时的动作镜像操作有关。</td></tr>
<tr><td></td><td></td><td></td></tr>
</tbody></table>
<p>P23</p>
<h2 id="不同reference-pose会引入的问题"><a class="header" href="#不同reference-pose会引入的问题">不同reference pose会引入的问题</a></h2>
<p><img src="./assets/04-09.png" alt="" /></p>
<blockquote>
<p>✅ 相同的姿态参数放在不同的参考姿态下呈现出的姿态不同。
✅ 解决方法：Retargeting</p>
</blockquote>
<p>P29</p>
<h1 id="retargeting-between-reference-poses"><a class="header" href="#retargeting-between-reference-poses"><strong>Retargeting</strong> between reference poses</a></h1>
<p><img src="./assets/04-10.png" alt="" /></p>
<blockquote>
<p>✅ 让不同参考姿态的角色做出同样的动作，根据 \(R_A\) 求 \(R_B\).<br />
✅ 重定向还有其它问题，例如关节长度、穿模。</p>
</blockquote>
<p>P33</p>
<h2 id="retargeting-for-a-single-object"><a class="header" href="#retargeting-for-a-single-object">Retargeting for a single object</a></h2>
<h3 id="问题分析"><a class="header" href="#问题分析">问题分析</a></h3>
<p><img src="./assets/04-12.png" alt="" /></p>
<h3 id="公式推导"><a class="header" href="#公式推导">公式推导</a></h3>
<p><img src="./assets/04-13.png" alt="" /></p>
<blockquote>
<p>✅ 把 B 先转到 A 的姿态，再做指定动作。</p>
</blockquote>
<p>P45</p>
<h2 id="retargeting-for-a-chain-of-links"><a class="header" href="#retargeting-for-a-chain-of-links">Retargeting for a chain of links</a></h2>
<h3 id="问题分析-1"><a class="header" href="#问题分析-1">问题分析</a></h3>
<p><img src="./assets/04-14.png" alt="" /></p>
<blockquote>
<p>✅ 两个关节的场景</p>
</blockquote>
<h3 id="公式推导-1"><a class="header" href="#公式推导-1">公式推导</a></h3>
<p>P49</p>
<p><img src="./assets/04-15.png" alt="" /></p>
<h3 id="结论-6"><a class="header" href="#结论-6">结论</a></h3>
<p>P51</p>
<p><img src="./assets/04-16.png" alt="" /></p>
<p>P52</p>
<h2 id="retargeting-between-reference-poses-1"><a class="header" href="#retargeting-between-reference-poses-1"><strong>Retargeting</strong> between reference poses</a></h2>
<h3 id="问题分析-2"><a class="header" href="#问题分析-2">问题分析</a></h3>
<p><img src="./assets/04-17.png" alt="" /></p>
<p>P53</p>
<h3 id="结论-7"><a class="header" href="#结论-7">结论</a></h3>
<p><img src="./assets/04-18.png" alt="" /></p>
<p>P101</p>
<h1 id="keyframe-animation-and-interpolation"><a class="header" href="#keyframe-animation-and-interpolation">Keyframe Animation and Interpolation</a></h1>
<blockquote>
<p>✅ Keyframe Animation跳过</p>
</blockquote>
<p>P106</p>
<h2 id="interpolation-2"><a class="header" href="#interpolation-2">Interpolation</a></h2>
<ul>
<li>Given a set of data pairs \(D=\){\((x_i,y_i)\mid i=0,\dots ,N\)} find a function \(f(x)\) such that</li>
</ul>
<p>P107</p>
<p><img src="./assets/04-26.png" alt="" /></p>
<p>常见的差值方法有Linear Interpolation、Polynomial Interpolation等。详见GAMES102。</p>
<p>P114</p>
<h2 id="smoothness"><a class="header" href="#smoothness">Smoothness</a></h2>
<p><img src="./assets/04-28.png" alt="" /></p>
<h2 id="interpolation-of-rotations"><a class="header" href="#interpolation-of-rotations">Interpolation of Rotations</a></h2>
<p>P154</p>
<p><img src="./assets/04-30.png" alt="" /></p>
<p>P157<br />
SLERP for Quaternions</p>
<p>$$
q_t=\frac{\sin[(1-t)\theta ]}{\sin \theta } q_0 + \frac{\sin t \theta }{\sin \theta }q_1
$$</p>
<p>$$
\cos \theta = q_0 \cdot q_1
$$</p>
<p>Constant rotational speed, but only “linear” interpolation</p>
<p>P158</p>
<blockquote>
<p>🔎 Animating rotation with quaternion curves.<br />
Ken Shoemake. 1985<br />
<em>SIGGRAPH Computer Graphics,</em></p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline-3"><a class="header" href="#outline-3">Outline</a></h1>
<ul>
<li>
<p>Motion Capture</p>
<ul>
<li>History and modern mocap systems</li>
</ul>
</li>
<li>
<p>Motion Synthesis</p>
<ul>
<li>Motion retargeting</li>
<li>Motion transition</li>
<li>Motion graph</li>
</ul>
</li>
</ul>
<p>P3</p>
<h1 id="motion-capture-1"><a class="header" href="#motion-capture-1">Motion Capture</a></h1>
<p>How to get motion data?</p>
<blockquote>
<p>✅ 动画师制作，光学动捕、视觉动捕，外骨骼动捕，惯性传感器，动作估计。</p>
</blockquote>
<p>P29</p>
<h1 id="motion-synthesis"><a class="header" href="#motion-synthesis">Motion Synthesis</a></h1>
<p>How to use motion data?</p>
<p>P31</p>
<p><img src="./assets/05-02.png" alt="" /></p>
<p>P32</p>
<h2 id="motion-retargeting-1"><a class="header" href="#motion-retargeting-1">Motion Retargeting</a></h2>
<h3 id="retargeting要解决的问题"><a class="header" href="#retargeting要解决的问题">Retargeting要解决的问题</a></h3>
<ul>
<li>Retarget a motion to drive a character with
<ul>
<li>Different number of bones</li>
<li>Different bone names</li>
<li>Different reference pose</li>
<li>Different bone ratios</li>
<li>Different skeletal structure</li>
<li>……</li>
</ul>
</li>
</ul>
<p>P34</p>
<h3 id="a-possible-retargeting-pipeline"><a class="header" href="#a-possible-retargeting-pipeline">A possible retargeting pipeline</a></h3>
<ul>
<li>Map bone names</li>
<li>Scale translations</li>
<li>Copy or retarget joint rotations to fix reference pose</li>
<li>Postprocessing with IK
<ul>
<li>Foot-skating</li>
<li>Self penetration</li>
</ul>
</li>
<li>……</li>
</ul>
<p><img src="./assets/05-03.png" alt="" /></p>
<p><img src="./assets/05-04.png" alt="" /></p>
<p>P38</p>
<h2 id="motion-transition"><a class="header" href="#motion-transition">Motion Transition</a></h2>
<blockquote>
<p>✅ 有一段走路数据和跑步数据，如何实现人由走到跑的过程。</p>
</blockquote>
<h3 id="方法一"><a class="header" href="#方法一">方法一</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/05-05.png" alt="" /></td><td>✅（1）找到两个 motion 中相似的一帧。</td></tr>
<tr><td><img src="./assets/05-06.png" alt="" /></td><td>✅（2）两帧在时间上对齐</td></tr>
<tr><td><img src="./assets/05-07.png" alt="" /></td><td>✅（3）放到这一帧时动作切换。</td></tr>
</tbody></table>
<blockquote>
<p>✅ 缺点：会有明显间断。</p>
</blockquote>
<h3 id="方法二"><a class="header" href="#方法二">方法二</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/05-08.png" alt="" /></td><td>✅ 改进：考虑前后帧，并做插值。</td></tr>
<tr><td><img src="./assets/05-09.png" alt="" /></td><td></td></tr>
</tbody></table>
<p>P46</p>
<p>$$
p(t)=(1-\phi (t))p_0(i)+\phi (t)p_1(i)
$$</p>
<blockquote>
<p>✅ 不一定非要线性插值，定义 \(\phi (t)\)，或其它混合策略<br />
✅ 可能存在的问题：（1）突然转向（2）滑步<br />
✅ 当走和跑分别是朝不同方法时会出现以上问题。<br />
✅ 解决方法：插值之前动作对齐</p>
</blockquote>
<p>P55</p>
<h3 id="facing-frame"><a class="header" href="#facing-frame">“Facing Frame”</a></h3>
<h4 id="定义坐标系"><a class="header" href="#定义坐标系">定义坐标系</a></h4>
<p>每个角色有自己的角色坐标系，定义为：<br />
A special coordinate system that moves horizontally with the character with one axis pointing to the “facing direction” of the character</p>
<blockquote>
<p>✅ 原点：Hip 在地面上的投影<br />
✅ 坐标轴：参考姿态下 \(y\) up \(z\) forward.且旋转和平移都受到限制。</p>
</blockquote>
<p><img src="./assets/05-10.png" alt="" /></p>
<p>$$
\begin{align*}
R &amp; = \theta e_y \\
t &amp; = (t_x,0,t_z)
\end{align*}
$$</p>
<blockquote>
<p>✅ 也可以为不同的的场景定义不同的 \(R\) ，例如上下半身的 \(y\) 轴旋转方向不同。</p>
</blockquote>
<ul>
<li>Possible definitions of \(R\)
<ul>
<li>\(R\) is the <strong>y-rotation</strong> that aligns the z-axis of the global frame to the heading direction</li>
<li>\(R\) is the <strong>y-rotation</strong> that aligns x-axis of the global frame to the average direction of the vectors between shoulders and hips</li>
<li>Decomposition root rotation as \(R_0=R_yR_{xz}\)</li>
</ul>
</li>
</ul>
<p>P58</p>
<h4 id="动作分解"><a class="header" href="#动作分解">动作分解</a></h4>
<p><img src="./assets/05-11-1.png" alt="" /></p>
<blockquote>
<p>✅ 把 \(R\) 分解为 \(R_y\) 和 \(R_{xz}\)，求 \(R_y\)<br />
✅ \({R}' \) 能够把 local y-axis 转到 global y-axis 的矩阵。</p>
</blockquote>
<p>P62</p>
<h4 id="动作合成"><a class="header" href="#动作合成">动作合成</a></h4>
<ul>
<li>How to compute this transformation?</li>
</ul>
<p><img src="./assets/05-12.png" alt="" /></p>
<blockquote>
<p>✅ 两个坐标系的转换。</p>
</blockquote>
<p>P68</p>
<h2 id="path-fitting"><a class="header" href="#path-fitting">Path Fitting</a></h2>
<p><img src="./assets/05-13.png" alt="" /> </p>
<blockquote>
<p>👆 让角色跟着轨迹移动。</p>
</blockquote>
<p>P69</p>
<h2 id="motion-composition"><a class="header" href="#motion-composition">Motion Composition</a></h2>
<p>Computationally generating motions according to<br />
- User control<br />
- Objects in the same environment<br />
- Movements of other characters<br />
- ……</p>
<p>P70</p>
<h3 id="motion-graphs-1"><a class="header" href="#motion-graphs-1">Motion Graphs</a></h3>
<p><img src="./assets/05-14.png" alt="" /><br />
<img src="./assets/05-15.png" alt="" /></p>
<blockquote>
<p>👆 动作图的本质是状态机。</p>
</blockquote>
<p>P72</p>
<h4 id="segment-motion-data"><a class="header" href="#segment-motion-data">Segment Motion Data</a></h4>
<p><img src="./assets/05-16.png" alt="" /> </p>
<blockquote>
<p>✅ 一段动捕数据，如何做分割，如何确定哪些点可以连到一起。<br />
✅ Distance 可以有多种定义方式。<br />
✅ 根据图确定分段与连接。</p>
</blockquote>
<p>P73</p>
<h4 id="建立动作转移关系"><a class="header" href="#建立动作转移关系">建立动作转移关系</a></h4>
<p><img src="./assets/05-17.png" alt="" /></p>
<ul>
<li>Distance map
<ul>
<li>Each pixel represents the difference between a pair of poses</li>
<li>Local minima are potential transition point</li>
</ul>
</li>
</ul>
<blockquote>
<p>🔎 <strong>Motion graphs</strong>
Lucas Kovar, Michael Gleicher, and Frédéric Pighin. 2002.<br />
<em>ACM Trans. Graph</em>. 21, 3 (July 2002),</p>
</blockquote>
<p>P74</p>
<h4 id="motion-synthesis-1"><a class="header" href="#motion-synthesis-1">Motion Synthesis</a></h4>
<ul>
<li>State-machines
<ul>
<li>Nodes represent motion clips</li>
<li>Edges represent potential transitions</li>
<li>Transitions are triggered when necessary
<ul>
<li>User input</li>
<li>Clip end</li>
</ul>
</li>
<li>Check immediate connections for the next clip
<ul>
<li>May need deeper search</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="./assets/05-18.png" alt="" /> </p>
<p>P75</p>
<h4 id="interactive-animation-pipeline"><a class="header" href="#interactive-animation-pipeline">Interactive Animation Pipeline</a></h4>
<p><img src="./assets/05-19.png" alt="" /></p>
<blockquote>
<p>✅ 优点：根据路线从动作库中选择最合适的动作，而不是直接使用路线，因此减少滑步。<br />
✅ 缺点：(1) 动作多时动作复杂。<br />
(2) 一个片断播完再切动作，响应较慢。<br />
(3) 需要提前规划好动捕动作。<br />
✅ 如果数据集里没有想要的姿态，可以结合 IK.</p>
</blockquote>
<p>P78</p>
<h3 id="motion-matching"><a class="header" href="#motion-matching">Motion Matching?</a></h3>
<ul>
<li>Clip → Pose</li>
<li>Short clip → “Raw” and long motion data</li>
</ul>
<blockquote>
<p>✅ 切换粒度更细：1帧 or 0.1 s．<br />
✅ 灵活性提升，可控性欠缺。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P1</p>
<blockquote>
<p>✅ 基于数据：对现有数据进行连接重组。<br />
✅ 基于学习：对数据处理，放入模型，再生成数据。</p>
</blockquote>
<p>P2</p>
<h1 id="outline-4"><a class="header" href="#outline-4">Outline</a></h1>
<ul>
<li>Recap: interactive character animation
<ul>
<li>Motion Graphs</li>
<li>Motion Matching</li>
</ul>
</li>
<li>Statistical Models of Human Motion
<ul>
<li>Principal Component Analysis</li>
<li>Gaussian Models</li>
</ul>
</li>
</ul>
<p>P3</p>
<h1 id="recap-interactive-animation"><a class="header" href="#recap-interactive-animation">Recap: Interactive Animation</a></h1>
<p>How to make a character respond to user command?</p>
<p><img src="./assets/06-01.png" alt="" /></p>
<p>P9</p>
<h2 id="motion-graphs-2"><a class="header" href="#motion-graphs-2">Motion Graphs</a></h2>
<p><img src="./assets/06-02.png" alt="" /></p>
<blockquote>
<p>✅ 检测到用户输入后：</p>
<ol>
<li>把当前片段播完（响应慢）</li>
<li>所有下一片断与当前状态进行坐标系对齐</li>
<li>根据当前状态和预期轨迹，选择下一个片断</li>
<li>播放对齐后的下一片断</li>
</ol>
<p>✅ 可以结合路径规划算，实现一些智能角色。Motion Graph 只是一个底层数据结构。</p>
</blockquote>
<p>P14</p>
<h2 id="motion-fields"><a class="header" href="#motion-fields">Motion Fields</a></h2>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Motion Graphs / State Machines</td><td>Motion Fields / Motion Matching</td></tr>
<tr><td><img src="./assets/06-03.png" alt="" /></td><td><img src="./assets/06-04.png" alt="" /></td></tr>
</tbody></table>
<blockquote>
<p>✅ Motion Matching 是将 Motion Fields 简化以后加一些比较好的工程实践。</p>
</blockquote>
<p>P17</p>
<h3 id="构建-motion-fields"><a class="header" href="#构建-motion-fields">构建 Motion Fields</a></h3>
<p><img src="./assets/06-05.png" alt="" /></p>
<blockquote>
<p>✅ 每条链路代表一个动作，灰圈代表动作里的一帧，整体构成一个很大的 Field.</p>
</blockquote>
<p>P20</p>
<h3 id="在motion-fields中选择pose"><a class="header" href="#在motion-fields中选择pose">在Motion Fields中选择pose</a></h3>
<p><img src="./assets/06-06.png" alt="" /></p>
<blockquote>
<p>✅ 每一帧有一些最近邻，它们来自不同动作，有不同的状态。<br />
✅ 绿色代表向右，挑出对应帧。做混合。</p>
</blockquote>
<p>P23</p>
<h3 id="对pose的混合"><a class="header" href="#对pose的混合">对pose的混合</a></h3>
<p><img src="./assets/06-07.png" alt="" /></p>
<p><img src="./assets/06-08.png" alt="" /></p>
<blockquote>
<p>✅ 根据用户输入设置不同权重，会得到不同结果<br />
✅ 优点：(1) 自由控制（2）支持外力，可结果物理仿真（3）不需要使首尾帧相似的预处理。<br />
✅ 缺点：需要设计一些规则来计算最近邻的混合。<br />
✅ 解决方法：强化学习</p>
</blockquote>
<p>P24</p>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<p><img src="./assets/06-09.png" alt="" /></p>
<blockquote>
<p>✅ 根据用户输入设计邻局的权重，这一步难以工业化。<br />
✅ 论文使用强化学习来解决，这样增加了训练的难度。</p>
</blockquote>
<p>P31</p>
<h2 id="motion-matching-1"><a class="header" href="#motion-matching-1">Motion Matching</a></h2>
<p><img src="./assets/06-10.png" alt="" /></p>
<p>P32</p>
<blockquote>
<p>✅ 简化一：只找一个最近邻，不需要 blend. 然后用平滑解决跳变问题。</p>
</blockquote>
<p>P34</p>
<h3 id="距离衡量函数"><a class="header" href="#距离衡量函数">距离衡量函数</a></h3>
<p>We need a distance function / metric to define the nearest neighbor</p>
<p>$$
\text{next-pose } = \min_{i \in\text{ Dataset}} ||x_{\text{curr}}-x_i||
$$</p>
<p>$$
x: \text{feature vector}
$$</p>
<blockquote>
<p>✅ Motion Matching 中距离函数的设计很重要，很大程度上影响算法的效果。<br />
✅ 这个距离定义可以是特征相关的。</p>
</blockquote>
<p>A possible set of feature vectors:</p>
<ul>
<li>root linear/angular velocity</li>
<li>position of end effectors w.r.t. root joint</li>
<li>linear/angular velocity of end effectors w.r.t. root joint</li>
<li><strong>future</strong> heading position/orientation (e.g. in 0.5s, 1.0s, 1.5s, etc.)</li>
<li>foot contacts</li>
<li>……</li>
</ul>
<p>P36</p>
<h3 id="动作平滑"><a class="header" href="#动作平滑">动作平滑</a></h3>
<p>We need a smooth motion</p>
<ul>
<li>Only do the search every few frames</li>
<li>Smoothly blend current pose to the target pose
<ul>
<li>Inertialized blending (ref. <a href="https://www.theorangeduck.com/page/spring-roll-call">https://www.theorangeduck.com/page/spring-roll-call</a> by Daniel Holden)</li>
</ul>
</li>
</ul>
<h3 id="搜索效率"><a class="header" href="#搜索效率">搜索效率</a></h3>
<p>We need a good performance</p>
<ul>
<li>An efficient data structure for searching，例如 e.g. KD-tree</li>
</ul>
<h3 id="数据集"><a class="header" href="#数据集">数据集</a></h3>
<p>A efficient dataset，例如“Dance card”</p>
<p><img src="./assets/06-11-1.png" alt="" /></p>
<blockquote>
<p>✅ 保证所使用的动作集能够覆盖到目标。<br />
✅ 优点：(1) 实现简单  (2) 控制灵活  (3) 可结合物理仿真。<br />
✅ 缺点：(1) 不能解决滑步</p>
</blockquote>
<p>P39</p>
<h1 id="statistical-models-of-human-motion"><a class="header" href="#statistical-models-of-human-motion">Statistical Models of Human Motion</a></h1>
<blockquote>
<p>✅ 根据已有数据，对“动作自然”建模。<br />
✅ 或找到一个模型，告诉我们什么是自然姿态。</p>
</blockquote>
<p>P43<br />
因为由于以下原因， “自然的动作”实际上是够成高维的动作参数空间的流形曲面。</p>
<ul>
<li>Coordinated arm/leg movement</li>
<li>Musculoskeletal structure</li>
<li>Laws of physics</li>
<li>……</li>
</ul>
<p>P45</p>
<h2 id="principal-component-analysis-pca"><a class="header" href="#principal-component-analysis-pca">Principal Component Analysis (PCA)</a></h2>
<ul>
<li>A technique for
<ul>
<li>finding out the correlations among dimensions</li>
<li>dimensionality reduction</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ PCA 细节跳过。目的：降维，抓住主要特征。</p>
</blockquote>
<p>P65</p>
<p>a pose \(x\) with smaller \(\sum _k\frac{((x-\bar{x})\cdot u_k)^2 }{\sigma ^2_k}\) is more likely to be a good pose</p>
<p><img src="./assets/06-12.png" alt="" /></p>
<blockquote>
<p>✅ 可作为动作生成的先验，告诉我一个动作是否合理。<br />
✅ \(M_k\) 和 \(\sigma_k\) 分别是 \(k\) 维上的均值和方差。</p>
</blockquote>
<p>P66</p>
<h2 id="character-ik-with-a-motion-prior"><a class="header" href="#character-ik-with-a-motion-prior">Character IK with a Motion Prior</a></h2>
<h3 id="正则化先验"><a class="header" href="#正则化先验">正则化先验</a></h3>
<p>$$
F(\theta )=\frac{1}{2} \sum_{i}^{} ||f_i(\theta )-\tilde{x} _i||^2_2+\frac{\lambda }{2}||\theta ||^2_2 
$$</p>
<p>$$
\theta=(t_0,R_0,R_1,R_2\dots  \dots )
$$</p>
<blockquote>
<p>✅ 正则项代表主观先验: \(\theta \) 小更有可能是合理动作。</p>
</blockquote>
<p>P68</p>
<h3 id="pca先验"><a class="header" href="#pca先验">PCA先验</a></h3>
<p>$$
F(\theta )=\frac{1}{2} \sum_{i}^{} ||f_i(\theta )-\tilde{x} _i||^2_2
$$</p>
<p>$$
+\frac{w }{2}\sum_{k}^{}(\frac{(\theta -\bar{\theta })\cdot u_k }{\sigma _k} )^2
$$</p>
<blockquote>
<p>✅ 把 P65 方法应用到 IK 来判断动作好坏的实例。<br />
✅ 改进为基于统计的先验。</p>
</blockquote>
<p>P71</p>
<h2 id="data-distribution"><a class="header" href="#data-distribution">Data Distribution</a></h2>
<p>\(p(x)\) : probability that \(x\) is a natural pose</p>
<blockquote>
<p>✅ 假设存在这样一个分布，但不知道分布的具体形式，要估计这样的分布<br />
✅（1）从分布中采样，例如：动捕<br />
✅（2）通过各种模型把分布估计出来，即从数据中估计出模型参数。</p>
</blockquote>
<p>P75</p>
<h2 id="gaussian-distribution"><a class="header" href="#gaussian-distribution">Gaussian Distribution</a></h2>
<blockquote>
<p>✅ 假设分布就是高斯分布</p>
</blockquote>
<p><img src="./assets/06-19-1.png" alt="" /></p>
<p>通过Maximum Likelihood Estimators (MLE，最大似然估计)得到:</p>
<p>$$
\begin{align*}
\bar{x}  &amp;= \frac{1}{N} \sum_{i}^{} x_i \\
\Sigma  &amp;  =\frac{1}{N} X^TX
\end{align*}
$$</p>
<p>P76</p>
<h3 id="pca-可以看作一种高斯分布"><a class="header" href="#pca-可以看作一种高斯分布">PCA 可以看作一种高斯分布。</a></h3>
<p>$$
\sum =X^TX=U\begin{bmatrix}
\sigma ^2_1 &amp;  &amp;  &amp; \\
&amp; \sigma ^2_2 &amp;  &amp; \\
&amp;  &amp; \ddots  &amp; \\
&amp;  &amp;  &amp;\sigma ^2_N
\end{bmatrix}U^T
$$</p>
<p>$$
x-\bar{x} =\sum_{k=1}^{n} w_ku_k
$$</p>
<blockquote>
<p>✅ PCA 分解可以看作是坐标转换或变量代换。</p>
</blockquote>
<p>P77</p>
<p><img src="./assets/06-13.png" alt="" /></p>
<p>P78</p>
<h2 id="character-ik-with-a-motion-prior-1"><a class="header" href="#character-ik-with-a-motion-prior-1">Character IK with a Motion Prior</a></h2>
<p>$$
F(\theta )=\frac{1}{2} \sum_{i} ||f_i(\theta )-\tilde{x} _i||^2_2+\frac{w}{2}\sum_k(\frac{(\theta -\bar{\theta })\cdot u_k }{\sigma _k} )^2 
$$</p>
<p>P79</p>
<p>$$
F(\theta )=\frac{1}{2} \sum_{i}^{} ||f_i(\theta )-\tilde{x} _i||^2_2-w \log \prod_k e^{-\frac{1}{2}(\frac{(\theta -\bar{\theta })\cdot u_k }{\sigma _k} )^2 }
$$</p>
<p>P80</p>
<p>$$
F(\theta )=\frac{1}{2} \sum_{i}^{} ||f_i(\theta )-\tilde{x} _i||^2_2-w \log p(\theta )<br />
$$</p>
<p>$$
\theta=(t_0,R_0,R_1,R_2\dots \dots )
$$</p>
<blockquote>
<p>✅ 第一项：符合目标。第二项：动作合理。</p>
</blockquote>
<p>P81</p>
<h3 id="motion-synthesis-with-a-motion-prior"><a class="header" href="#motion-synthesis-with-a-motion-prior">Motion Synthesis with a Motion Prior</a></h3>
<p>Given a motion prior \(p(x)\) learned from a set of data points \(D \)= {\(x_i\)}, Synthesize a motion \(x\) that minimize the objective</p>
<p>$$
f(x)=f(x)-w \log p(x )
$$</p>
<p>Note: \(x\) can represent a pose \(\theta\)<br />
\(\quad\quad\) or a motion clip → a sequence of poses {\( \theta t\)}<br />
\(\quad\quad\) or any features of a motion → e.g. \(w_k\) in PCA</p>
<blockquote>
<p>✅ \(x\) 可以不局限于 \(\theta \)、而是任何一个可以描述 motion 的量。<br />
✅ \(f(x)\) 代表目标，目标也不局限于 IK，也可以是Keyframes、User control、Environment constraints等<br />
✅ 但“认为动作符合高斯分布”仍然是一个非常受限约束，难以用于复杂的动作</p>
</blockquote>
<p>P83</p>
<h3 id="相关工作"><a class="header" href="#相关工作">相关工作</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/06-14.png" alt="" /></td><td></td></tr>
<tr><td><img src="./assets/06-15.png" alt="" /></td><td>✅ 使用高斯混合模型，用于动作编辑。<br> ✅ \(x\) 不局限于单帧动作，也可以是一个序列。</td></tr>
<tr><td>Min et al. 2009</td><td>✅ 视频动捕是欠约束问题，但可以通过分布过滤掉不合理的结果。</td></tr>
<tr><td><img src="./assets/06-16.png" alt="" /></td><td>✅ 缺点：实现麻烦，很多超参。</td></tr>
<tr><td><img src="./assets/06-22.png" alt="" /></td><td>[Starke et al 2020, Local Motion Phases for Learning Multi-Contact Character Movements]</td></tr>
<tr><td><img src="./assets/06-23.png" alt="" /></td><td>[Henter et al. 2020, MoGlow: Probabilistic and Controllable Motion Synthesis Using Normalising Flows]</td></tr>
<tr><td><img src="./assets/06-24.png" alt="" /></td><td>[Lee et al 2019, Interactive Character Animation by Learning Multi-Objective Control]</td></tr>
<tr><td><img src="./assets/06-25.png" alt="" /></td><td>[Holden et al 2020, Learned Motion Matching]<br> ✅ 用 DL 代替复杂的模型，来估计动作先验。</td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline-5"><a class="header" href="#outline-5">Outline</a></h1>
<ul>
<li>Learning-based Character Animation (cont.)
<ul>
<li>Motion Models</li>
<li>Autoregressive models: PFNN</li>
<li>Generative models</li>
</ul>
</li>
</ul>
<p>P4</p>
<h1 id="learning-motion-models"><a class="header" href="#learning-motion-models">Learning Motion Models</a></h1>
<h2 id="问题的数学建模"><a class="header" href="#问题的数学建模">问题的数学建模</a></h2>
<p>\(p(x)\): probability that 𝒙 is a natural motion</p>
<p>由于 \(p(x)\) 无法由计算得出，所以从数据去学。数据即 a set of example motions {\(x_i\)}∼ \(p(x)\) </p>
<p>P5</p>
<h3 id="数学模型1"><a class="header" href="#数学模型1">数学模型1</a></h3>
<p><img src="./assets/06a-01.png" alt="" /></p>
<blockquote>
<p>✅ 一个pose可以用每个关节的位置表示，也可以用每个关节的旋转表示。如果用位置约束，最后需要通过IK变成旋转的约束。如果用旋转约束，就难以做到需要约束位置的效果。<br />
✅ P(X)判断整个序列所有pose的联合分布是否合理。</p>
</blockquote>
<p>P7</p>
<h3 id="数学模型2"><a class="header" href="#数学模型2">数学模型2</a></h3>
<p>$$
p(X\mid z)=p(x_1,\dots ,x_T\mid z)
$$</p>
<p>$$
\begin{align*}
𝑧: &amp; \text{ control parameters} \\
&amp; \text{ latent variables} \\
&amp; …… 
\end{align*}
$$</p>
<blockquote>
<p>✅ 对动作序列的要求，除了动作合理，还要符合用户期待，用户要求可以是显式的，例如往左走；也可以是隐式的，例如以老人的风格走。\(z\) 代表用户条件。<br />
✅ P(X|z)判断在条件z下整个序列所有pose的联合分布是否合理。</p>
</blockquote>
<p>P8</p>
<p>$$
(x_1,\dots ,x_T)=f(z)
$$</p>
<p>$$
\begin{align*}
𝑧: &amp; \text{ control parameters} \\
&amp; \text{ latent variables} \\
&amp; …… 
\end{align*}
$$</p>
<blockquote>
<p>✅ 如果概率分布是正确的，基于这个分布采样能得到一个合理的动作，且满足前提条件。</p>
</blockquote>
<p>P14</p>
<h3 id="数学模型3"><a class="header" href="#数学模型3">数学模型3</a></h3>
<p>$$
p(X\mid z)=p(x_1,\dots ,x_T\mid z)
$$</p>
<p>$$
=p(x_1)\prod_{t}^{} p(x_t\mid x_{t-1},\dots ,x_1;z)
$$</p>
<p>\(^\ast \) The chain rule of conditional probabilities:</p>
<p>$$
\begin{align*}
p(x_1,x_2,x_3) &amp; = p(x_2,x_3 \mid x_1)p(x_1) \\
&amp; = p(x_3 \mid x_2, x_1)p( x_2 \mid x_1)p(x_1)
\end{align*}
$$</p>
<blockquote>
<p>✅ 序列合理 ＝ 已知序列中的前 \(t-1\) 帧时第 \(t\) 帧应当合理。</p>
</blockquote>
<p>P15<br />
采样过程为：</p>
<p>$$
x_t=f(x_{t-1},x_{t-2},\dots x_1;z)
$$</p>
<p>P17</p>
<h3 id="数学模型4"><a class="header" href="#数学模型4">数学模型4</a></h3>
<blockquote>
<p>✅ 假设动作具有Markov 性（无记忆性） </p>
</blockquote>
<p>$$
x_t=f(x_{t-1};z)
$$</p>
<p>Markov Property</p>
<blockquote>
<p>✅ \(x_t\) 只受 \(x_{t-1}\) 影响，与 \(t-1\) 之前的动作无关。</p>
</blockquote>
<p>P18</p>
<h3 id="two-perspectives-on-a-motion-sequence"><a class="header" href="#two-perspectives-on-a-motion-sequence">Two Perspectives on a Motion Sequence</a></h3>
<table><thead><tr><th>数学模型3</th><th>数学模型4</th></tr></thead><tbody>
<tr><td><img src="./assets/06a-03.png" alt="" /></td><td><img src="./assets/06a-04.png" alt="" /></td></tr>
<tr><td><img src="./assets/06a-05.png" alt="" /></td><td><img src="./assets/06a-06.png" alt="" /></td></tr>
<tr><td>✅ 无交互无实时通常用前者</td><td>✅ 游戏里面通常用后者</td></tr>
<tr><td>✅ 左：直接生成所有动作。</td><td>✅ 右：一帧一帧地生成。</td></tr>
<tr><td></td><td>✅ 右无法考虑未来，不能根据将要发生的事情调整当前的动作。（自回归）</td></tr>
</tbody></table>
<p>P25</p>
<h2 id="数学模型"><a class="header" href="#数学模型">数学模型</a></h2>
<p>$$
x_t=f(x_{t-1})
$$</p>
<p><img src="./assets/06a-07.png" alt="" /></p>
<blockquote>
<p>✅ 由于只和上一帧相关，二元组 \(（x_{t-1}，x_t）\) 构成了一个数据，希望从里面学到一些信息。<br />
✅ Neural Network 相关部分跳过。<br />
✅ 当前先不考虑 \(z\)<br />
✅ 可以把它当作优化问题来解。</p>
</blockquote>
<p>P40</p>
<h2 id="ambiguity-issue"><a class="header" href="#ambiguity-issue">Ambiguity Issue</a></h2>
<p>$$
x_t=f(x_{t-1})
$$</p>
<p><img src="./assets/06a-08.png" alt="" /></p>
<blockquote>
<p>✅ 但是 \(x_t\) 和 \(x_{t-1}\) 的关系是有歧义性的，最后学到一个平均的 \(x_t\).<br />
✅ 因为\(x_{t-1}\)与\(x_t\)不是一对一的mapping关系。</p>
</blockquote>
<p>P41</p>
<h2 id="hidden-variables"><a class="header" href="#hidden-variables">Hidden Variables</a></h2>
<p>$$
x_t=f(x_{t-1};z)
$$</p>
<p><img src="./assets/06a-09.png" alt="" /></p>
<blockquote>
<p>✅ 需要加入一个额外的变量，可以来自用户输入或先验信息。关键是怎么找到 \(z\)，使学习比较有效。</p>
</blockquote>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td>113</td><td>2017</td><td>Phasefunctioned neural networks for character control</td><td>PFNN</td><td></td><td><a href="https://caterpillarstudygroup.github.io/ReadPapers/113.html">link</a></td></tr>
</tbody></table>
<p>P55</p>
<h3 id="相关工作-1"><a class="header" href="#相关工作-1">相关工作</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/06a-21.png" alt="" /></td><td>*SIGGRAPH 2018 <br> ✅ 论文一：除角色姿态，还考虑脚的速度。</td></tr>
<tr><td><img src="./assets/06a-22.png" alt="" /></td><td>*SIGGRAPH 2020 <br> ✅ 论文二：把两个脚拆开，并考虑手，分别定义相位函数。</td></tr>
<tr><td><img src="./assets/06a-023.png" alt="" /></td><td>*SIGGRAPH 2022 <br> ✅ 论文三：从数据中自动学到相位函数的组合。</td></tr>
</tbody></table>
<p>P57</p>
<h1 id="generative-models"><a class="header" href="#generative-models">Generative Models</a></h1>
<p><img src="./assets/06a-24.png" alt="" /></p>
<blockquote>
<p>✅ 不学两帧关系，而是直接学概率密度函数。<br />
✅ 难点：(1) 真实 PDF 可能非常复杂 (2) 从一个 PDF 中采样也很难。<br />
✅ PDF 的作用是判断动作是不是真的。</p>
</blockquote>
<p>P60</p>
<h2 id="常见套路"><a class="header" href="#常见套路">常见套路</a></h2>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>Generative Models</td><td>✅ 一般生成式模型是这样的形式：从一个简单的 PDF，通过 \(f(z)\)，映射到 \(p(x)\). <br> ✅ 关键是 \(f(z)\) 要学好。</td><td><img src="./assets/06a-025.png" alt="" /></td></tr>
<tr><td>Variational Autoencoders</td><td>✅ VAE：已知一些真实数据采样，用 Encoder 编码到简单分布上的点，再用Decoder 变回原分布上的点。<br> ✅ control VAE 是 VAE＋控制＋物理仿真</td><td><img src="./assets/06a-25.png" alt="" /></td></tr>
<tr><td>Generative Adversarial Network</td><td>✅ GAN：无 Encoder，增加一个判别器。 <br> ✅ ASE、AMP 是 GAN 的控制版本。 <br> ✅ RL 不结合物理难以 work，因为难以定义 reward.</td><td><img src="./assets/06a-26.png" alt="" /></td></tr>
<tr><td>Normalizing Flows</td><td>✅ 标准化流：类似 VAE，使用一个可逆函数。</td><td><img src="./assets/06a-27.png" alt="" /></td></tr>
<tr><td>Diffusion Models</td><td>✅ 扩散模型：多次编码与解码。  <br> ✅ 一个动作序列相当于隐空间里的一条轨迹。</td><td><img src="./assets/06a-28.png" alt="" /></td></tr>
</tbody></table>
<p>P62</p>
<h2 id="相关工作-2"><a class="header" href="#相关工作-2">相关工作</a></h2>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/06a-29.png" alt="" /></td><td>[Ling et al. 2021 Character Controllers Using Motion <strong>VAEs</strong>]</td></tr>
<tr><td><img src="./assets/06a-30.png" alt="" /></td><td>[Henter et al. 2020, MoGlow: Probabilistic and Controllable Motion Synthesis Using <strong>Normalising Flows</strong>]<br>✅ 利用 RL 等方法，在 lalent code 上生成轨迹，再把轨迹转到动作空间。</td></tr>
<tr><td><img src="./assets/06a-31.png" alt="" /></td><td>[Zhang et al. 2022, <strong>arXiv</strong>, MotionDiffuse: Text-Driven Human Motion Generation with <strong>Diffusion Model</strong>]</td></tr>
<tr><td><img src="./assets/06a-32.png" alt="" /></td><td>[Tevet et al. 2022, <strong>arXiv</strong>, MDM: Human Motion <strong>Diffusion Model</strong>]</td></tr>
<tr><td></td><td>Ganimator：小样本生成</td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline-6"><a class="header" href="#outline-6">Outline</a></h1>
<ul>
<li>
<p>Skinning</p>
<ul>
<li>Linear Blend Skinning (LBS)</li>
<li>Dual Quaternion Skinning (DQS)</li>
<li>Blendshapes</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li>The SMPL model</li>
<li>Facial Animation</li>
</ul>
</li>
</ul>
<blockquote>
<p>🔎 SIGGRAPH 经典的蒙皮课程。<br />
Many images are from: <a href="https://skinning.org/">https://skinning.org/</a><br />
<em>Alec Jacobson, Zhigang Deng, Ladislav Kavan, and J. P. Lewis. 2014</em>.<br />
<strong>Skinning: real-time shape deformation</strong>.<br />
<em>In ACM SIGGRAPH 2014 Courses (SIGGRAPH '14)</em></p>
</blockquote>
<p>P7</p>
<h1 id="skinning-deformation"><a class="header" href="#skinning-deformation">Skinning Deformation</a></h1>
<h2 id="绑定与蒙皮概念"><a class="header" href="#绑定与蒙皮概念">绑定与蒙皮概念</a></h2>
<blockquote>
<p>✅ Rigging：创建脸部控制器或身体骨骼。黄色为在 Mesh 顶点内放置的骨骼。<br />
✅ Sinning：让控制器带动皮肤运动。或让 Mesh 顶点跟着骨骼运动。</p>
</blockquote>
<p><img src="./assets/07-01.png" alt="" /></p>
<p><img src="./assets/07-02.png" alt="" /></p>
<p>P12</p>
<h2 id="skinning-deformation-1"><a class="header" href="#skinning-deformation-1">Skinning Deformation</a></h2>
<h3 id="计算方式一"><a class="header" href="#计算方式一">计算方式一</a></h3>
<p><img src="./assets/07-03.png" alt="" /></p>
<blockquote>
<p>✅ 骨骼运动的旋转和平移分别为 \(R\) 和 \(t\)，关节的位置和朝向则变成了 \({Q}'\) 和 \({o}'\).<br />
✅ 求 \(x\) 的新位置 \({x}'\). 本质上就是坐标系变换：世界坐标系 → \({o}\) 坐标系 → \({o}'\) 坐标系 → 世界坐标系</p>
</blockquote>
<p>P13</p>
<h3 id="计算方式二"><a class="header" href="#计算方式二">计算方式二</a></h3>
<p><img src="./assets/07-04.png" alt="" /> </p>
<blockquote>
<p>✅ \(r\) 为 \(x\) 在骨骼坐标的表达，用 \(r\) 计算更简洁。 </p>
</blockquote>
<p>P16</p>
<h2 id="bind-pose"><a class="header" href="#bind-pose">Bind Pose</a></h2>
<p><img src="./assets/07-06.png" alt="" /></p>
<blockquote>
<p>✅ 当骨骼参考姿态与 Mesh 参考姿态不一致时，需要先旋转骨骼到 Mesh 姿态。</p>
</blockquote>
<p>P20</p>
<h2 id="skinning-deformation---2-joints"><a class="header" href="#skinning-deformation---2-joints">Skinning Deformation - 2 joints</a></h2>
<p><img src="./assets/07-08.png" alt="" /></p>
<p>$$
r_2=Q^T_2(x-o_2)   \quad \quad  r_1=Q^T_1(x-o_1)
$$</p>
<blockquote>
<p>✅ 多骨骼场景，\(x\) 在关节 \(O_1\) 和 \(O_2\) 下分别 \(r_1\) 和 \(r_2\) 两种表达。</p>
</blockquote>
<p>P23<br />
<img src="./assets/07-09.png" alt="" /></p>
<blockquote>
<p>✅ 得到的旋转后表达分别为 \({x}'_1\) 和 \({x}'_2\)，通过权重对它们结合。</p>
</blockquote>
<p>P29<br />
<img src="./assets/07-10.png" alt="" /></p>
<blockquote>
<p>✅ 同时考虑所有 Mesh 顶点和所有关节。</p>
</blockquote>
<p>P31</p>
<h2 id="linear-blend-skinning-lbs"><a class="header" href="#linear-blend-skinning-lbs">Linear Blend Skinning (LBS)</a></h2>
<p>$$
{x}'_ i= \sum_ {j=1} ^ {m} w _ {ij}({Q}'_ jr_{ij}+{o}'_j)
$$</p>
<ul>
<li>Used widely in industry</li>
<li>Efficient and GPU-friendly
<ul>
<li>Games like it</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ Bind Pose：让骨骼与 Mesh 对齐，为 Bind Pose．<br />
✅ Bind Pose 情况下 Motion 不一定为零。</p>
</blockquote>
<p>P33</p>
<h2 id="automatic-skinning"><a class="header" href="#automatic-skinning">Automatic Skinning?</a></h2>
<table><thead><tr><th></th></tr></thead><tbody>
<tr><td><img src="./assets/07-11.png" alt="" /></td></tr>
<tr><td><img src="./assets/07-12.png" alt="" /></td></tr>
</tbody></table>
<p>Pinocchio [Baran et al., 2007]</p>
<p>P37</p>
<h2 id="linear-blend-skinning-lbs-1"><a class="header" href="#linear-blend-skinning-lbs-1">Linear Blend Skinning (LBS)</a></h2>
<p><img src="./assets/07-13.png" alt="" /></p>
<blockquote>
<p>✅ 公式第一项对 \(R_j\) 所加权，所得到的很有可能不再是旋转矩阵。</p>
</blockquote>
<p>存在的问题： Candy-Wrapper Artifact</p>
<p><img src="./assets/07-14.png" alt="" /></p>
<p>P40</p>
<h2 id="advanced-skinning-methods"><a class="header" href="#advanced-skinning-methods">Advanced Skinning Methods</a></h2>
<ul>
<li>
<p>Multi-linear Skinning (we will not cover this)</p>
<ul>
<li>Multi-weight enveloping [Wang and Phillips 2002]</li>
<li>Animation Space [Merry et al. 2006]</li>
<li>……</li>
</ul>
</li>
<li>
<p>Nonlinear Skinning</p>
<ul>
<li>Dual-quaternion Skinning (DQS)</li>
</ul>
</li>
</ul>
<p><img src="./assets/07-15.png" alt="" /></p>
<blockquote>
<p>✅ DQ：对偶四元数。</p>
</blockquote>
<p>P41</p>
<h2 id="non-linear-skinning"><a class="header" href="#non-linear-skinning">Non-linear Skinning</a></h2>
<p><img src="./assets/07-16.png" alt="" /></p>
<h3 id="quaternions-and-slerp"><a class="header" href="#quaternions-and-slerp">quaternions and SLERP</a></h3>
<p>Can we use quaternions and SLERP?</p>
<p>P42</p>
<p><img src="./assets/07-16-1.png" alt="" /></p>
<blockquote>
<p>✅ 不行。原因：第一项与第二项必须要配合好，否则会乱掉。</p>
</blockquote>
<p>P43</p>
<h3 id="从公式角度来解释不行的原因"><a class="header" href="#从公式角度来解释不行的原因">从公式角度来解释不行的原因</a></h3>
<p>$$
{x}' _ i = ( \sum _ {j=1}^{m} w _ {ij} R _ j) x _ i+ \sum _ {j=1}^{m}w _ {ij}t_ j
$$</p>
<p>$$
R \in SO(3)
$$</p>
<p>$$
T_j=\begin{bmatrix}
R_j &amp; t_j\\
0 &amp;1
\end{bmatrix} \in SE(3)
$$</p>
<blockquote>
<p>✅ \(T_j\) 构成一个刚性变换群。</p>
</blockquote>
<p>P46</p>
<h3 id="interpolation-in-𝑆𝑂3"><a class="header" href="#interpolation-in-𝑆𝑂3">Interpolation in 𝑆𝑂(3)</a></h3>
<p><img src="./assets/07-17.png" alt="" /></p>
<blockquote>
<p>✅ 线性插值和 SLERP 插值 SO(3) 上。</p>
</blockquote>
<p>P49</p>
<h3 id="interpolation-in-𝑆𝐸3"><a class="header" href="#interpolation-in-𝑆𝐸3">Interpolation in 𝑆𝐸(3)</a></h3>
<p><img src="./assets/07-18.png" alt="" /></p>
<blockquote>
<p>✅ SE（3）上的线性插值，插值到一个退化的点。</p>
</blockquote>
<p>P51</p>
<h3 id="intrinsic-blending"><a class="header" href="#intrinsic-blending">Intrinsic Blending</a></h3>
<p><img src="./assets/07-19.png" alt="" /></p>
<p>P52</p>
<h2 id="dual-quaternion-skinning-dqs"><a class="header" href="#dual-quaternion-skinning-dqs">Dual-Quaternion Skinning (DQS)</a></h2>
<ul>
<li>Approximation of intrinsic averages in SE(3)</li>
</ul>
<p>Ladislav Kavan, Steven Collins, Jiri Zara, Carol O‘Sullivan. <strong>Geometric Skinning with</strong><br />
<strong>Approximate Dual Quaternion Blending</strong>, ACM Transaction on Graphics, 27(4), 2008.</p>
<blockquote>
<p>✅ 把旋转 ＋ 平移的刚性变换表达为对偶四元数。</p>
</blockquote>
<p>P54</p>
<h3 id="dual-numbers"><a class="header" href="#dual-numbers">Dual Numbers</a></h3>
<p><img src="./assets/07-20.png" alt="" /></p>
<p>P55</p>
<h3 id="dual-quaternion"><a class="header" href="#dual-quaternion">Dual Quaternion</a></h3>
<ul>
<li>Dual quaternion</li>
</ul>
<p>$$
\hat{q} =q_0 + \varepsilon q_\varepsilon
$$</p>
<p>$$
\text{where } \varepsilon^2=0
$$</p>
<p>A good note of dual-quaternion:<br />
<a href="https://faculty.sites.iastate.edu/jia/files/inline-files/dual-quaternion.pdf">https://faculty.sites.iastate.edu/jia/files/inline-files/dual-quaternion.pdf</a></p>
<p>P56</p>
<h3 id="dual-quaternion-1"><a class="header" href="#dual-quaternion-1">Dual Quaternion</a></h3>
<ul>
<li>Scalar Multiplication</li>
</ul>
<p>$$
s\hat{q}=sq_r+sq_\varepsilon\varepsilon
$$</p>
<ul>
<li>Addition</li>
</ul>
<p>$$
\hat{q} _ 1 + \hat{q} _2=q _ {r1}+ q _ {r2} + \varepsilon (q _ {\varepsilon 1} + q _ {\varepsilon 2})
$$</p>
<ul>
<li>Multiplication</li>
</ul>
<p>$$
\hat{q} _ 1 \hat{q} _ 2 = q _ {r1} q _ {r2} + \varepsilon (q _ {r1} q _ {\varepsilon 2} + q _ {r2} q _ {\varepsilon 1})
$$</p>
<p>P57</p>
<h3 id="dual-quaternion-2"><a class="header" href="#dual-quaternion-2">Dual Quaternion</a></h3>
<ul>
<li>Dual quaternion</li>
</ul>
<p>$$
\hat{q}=q_0+\varepsilon q_\varepsilon
$$</p>
<ul>
<li>Conjugation</li>
</ul>
<p>$$
\mathrm{I}:\hat{q}^* =q ^ * _ 0+\varepsilon q ^ * _ \varepsilon
$$</p>
<p>$$
\mathrm{II}:\hat{q}^ {\circ}  =q _ 0 - \varepsilon q _ \varepsilon 
$$</p>
<p>$$
\mathrm{III}: \hat{q} ^ \star    = q ^ * _ 0 - \varepsilon q ^ *_ \varepsilon 
$$</p>
<p>$$
\quad \quad \quad \quad = ({\hat{q} ^ *}) ^ {\circ} = (\hat{q} ^ {\circ}) ^ *
$$</p>
<p>$$
(\hat{q} _1\hat{q}_2)^\times =\hat{q} _1 ^\times \hat{q}_2^\times
$$</p>
<ul>
<li>Norm</li>
</ul>
<p>$$
||\hat{q}||=\sqrt{\hat{q}^*\hat{q}} =||q_0||+\frac{\varepsilon (q_0\cdot q_\varepsilon) }{||q_0||} 
$$</p>
<p>P58</p>
<h3 id="dual-quaternion-3"><a class="header" href="#dual-quaternion-3">Dual Quaternion</a></h3>
<ul>
<li>Unit dual quaternion: \(||\hat{q}||=1\), which requires:</li>
</ul>
<p>$$
||q_0||=1
$$</p>
<p>$$
q_0 \cdot q_\varepsilon=0
$$</p>
<p>P59</p>
<h3 id="dual-quaternion--rigid-transformation"><a class="header" href="#dual-quaternion--rigid-transformation">Dual Quaternion ⇔ Rigid Transformation</a></h3>
<ul>
<li>Like quaternion, any rigid transformation \(T \in SE(3)\) can be converted <strong>into a unit dual quaternion</strong></li>
</ul>
<p>$$
Tx=Rx+t
$$</p>
<p>$$
T=[R\mid t]\to \hat{q} =q_0+\varepsilon q_\varepsilon 
$$</p>
<p>$$
\begin{matrix}
q_0=r \quad &amp; \text{ quaternion of } R \quad \quad\quad\quad\\
q_\varepsilon =\frac{1}{2} tr &amp; \text{ pure quaternion } t = (0,t)
\end{matrix}
$$</p>
<blockquote>
<p>✅ 把一个刚性变换表示为对偶四元数。</p>
</blockquote>
<p>P60</p>
<h3 id="dual-quaternion--rigid-transformation-1"><a class="header" href="#dual-quaternion--rigid-transformation-1">Dual Quaternion ⇔ Rigid Transformation</a></h3>
<ul>
<li>Transform a vector \(v\) using unit dual quaternion</li>
</ul>
<p>$$
{\hat{v} }' =\hat{q} \hat{v} \hat{q} ^\star 
$$</p>
<p>where</p>
<p>$$
\begin{align*}
\hat{v} &amp; = 1+\varepsilon (0,v) \\
&amp; =(1,0,0,0)+\varepsilon (0,v_x,v_y,v_z)
\end{align*}
$$</p>
<p>$$
\quad
$$</p>
<p>$$
\mathrm{III}: \hat{q} ^ \star    = q ^ * _ 0 - \varepsilon q ^ *_ \varepsilon 
$$</p>
<p>$$
\quad \quad \quad \quad = ({\hat{q} ^ *}) ^ {\circ} = (\hat{q} ^ {\circ}) ^ *
$$</p>
<p>P61</p>
<h3 id="dual-quaternion--rigid-transformation-2"><a class="header" href="#dual-quaternion--rigid-transformation-2">Dual Quaternion ⇔ Rigid Transformation</a></h3>
<ul>
<li>Like quaternion, any rigid transformation \(T \in SE(3)\) can be converted <strong>into a unit dual quaternion</strong></li>
</ul>
<p>$$
T=[R\mid t]\to \hat{q} =q_0+\varepsilon q_\varepsilon 
$$</p>
<p>$$
\begin{matrix}
q_0=r \quad \\
q_\varepsilon =\frac{1}{2} tr 
\end{matrix}
$$</p>
<p>\(\hat{q}\) and \(-\hat{q}\) represent the same transformation
\(\hat{Q}\) is a <strong>double cover</strong> of \(SE(3)\)</p>
<p>P62</p>
<h2 id="double-cover-visualized"><a class="header" href="#double-cover-visualized">Double Cover Visualized</a></h2>
<p><img src="./assets/07-21.png" alt="" /></p>
<p>P63</p>
<h2 id="interpolating-dual-quaternion"><a class="header" href="#interpolating-dual-quaternion">Interpolating Dual-Quaternion</a></h2>
<p><img src="./assets/07-22.png" alt="" /></p>
<p>P64</p>
<h2 id="dual-quaternion-linear-blending-dlb"><a class="header" href="#dual-quaternion-linear-blending-dlb">Dual-Quaternion Linear Blending (DLB)</a></h2>
<p><img src="./assets/07-022.png" alt="" /></p>
<p>P65</p>
<h2 id="dual-quaternion-skinning-dqs-1"><a class="header" href="#dual-quaternion-skinning-dqs-1">Dual-Quaternion Skinning (DQS)</a></h2>
<p><img src="./assets/07-23.png" alt="" /></p>
<p>P66</p>
<h2 id="budging-artifact-of-dqs"><a class="header" href="#budging-artifact-of-dqs">Budging Artifact of DQS</a></h2>
<p><img src="./assets/07-24.png" alt="" /></p>
<blockquote>
<p>✅ 越往右蒙皮权重越光滑。<br />
✅ DQBS 也有比较严重的 artifacts.</p>
</blockquote>
<p>P67</p>
<h2 id="how-to-correct-lbs"><a class="header" href="#how-to-correct-lbs">How to Correct LBS?</a></h2>
<p><img src="./assets/07-25.png" alt="" /></p>
<blockquote>
<p>✅ LBS 的天然缺陷</p>
</blockquote>
<p>P69</p>
<h2 id="how-to-correct-lbs-1"><a class="header" href="#how-to-correct-lbs-1">How to Correct LBS?</a></h2>
<p><img src="./assets/07-26.png" alt="" /></p>
<p>P74</p>
<h2 id="scattered-data-interpolation"><a class="header" href="#scattered-data-interpolation">Scattered Data Interpolation</a></h2>
<p><img src="./assets/07-27.png" alt="" /></p>
<p>P76</p>
<h2 id="scattered-data-interpolation-1"><a class="header" href="#scattered-data-interpolation-1">Scattered Data Interpolation</a></h2>
<ul>
<li>Linear
<ul>
<li>Least squares</li>
</ul>
</li>
<li>Splines</li>
<li>Inverse distance weighting</li>
<li>Gaussian process</li>
<li>Radial Basis Function</li>
<li>……</li>
</ul>
<p><img src="./assets/07-28.png" alt="" /></p>
<p>P81</p>
<h2 id="radial-basis-function-rbf-interpolation"><a class="header" href="#radial-basis-function-rbf-interpolation">Radial Basis Function (RBF) Interpolation</a></h2>
<p>$$
y=\sum_{i=1}^{k} w_i\varphi (||x-x_i||)
$$</p>
<p><img src="./assets/07-29.png" alt="" /></p>
<p>P83</p>
<h2 id="radial-basis-function-rbf-interpolation-1"><a class="header" href="#radial-basis-function-rbf-interpolation-1">Radial Basis Function (RBF) Interpolation</a></h2>
<p>$$
y=\sum_{i=1}^{k} w_i\varphi (||x-x_i||)
$$</p>
<p>How to compute \(w_i\) ? We need \(f(x_i)=y_i\)</p>
<p>$$
\begin{bmatrix}<br />
R_{1,1} &amp; R_{1,2} &amp; \cdots &amp; R_{1,K} \\<br />
R_{2,1} &amp; R_{2,2} &amp;   &amp; \vdots \\<br />
\vdots &amp;   &amp; \ddots &amp; \vdots \\<br />
R_{K,1} &amp; \cdots &amp; \cdots &amp; R_{K,K}<br />
\end{bmatrix} \begin{bmatrix}
w_1\\
w_2 \\
\vdots\\
w_K
\end{bmatrix}=\begin{bmatrix}
y_1\\
y_2 \\
\vdots\\
y_K
\end{bmatrix}
$$</p>
<p>$$
R_{i,j}=\varphi (||x_i-x_j||)
$$</p>
<p><img src="./assets/07-30.png" alt="" /></p>
<p>P84</p>
<h2 id="radial-basis-function-rbf"><a class="header" href="#radial-basis-function-rbf">Radial Basis Function (RBF)</a></h2>
<p>$$
y=\sum_{i=1}^{k} w_i\varphi (||x-x_i||)
$$</p>
<ul>
<li>Gaussian:</li>
</ul>
<p>$$
\varphi (r)=e^{-(r/c)^2}
$$</p>
<ul>
<li>Inverse multiquadric:</li>
</ul>
<p>$$
\varphi (r)=\frac{1}{\sqrt{r^2+c^2} } 
$$</p>
<ul>
<li>Thin plate spline:</li>
</ul>
<p>$$<br />
\varphi (r)=r^2 \log r
$$</p>
<ul>
<li>Polyharmonic splines:</li>
</ul>
<p>$$
\varphi (r)=\begin{cases}
r^k,k=2n+1\\
\\<br />
r^k \log r,k=2n
\end{cases}
$$</p>
<p>P85</p>
<h2 id="pose-space-deformation"><a class="header" href="#pose-space-deformation">Pose Space Deformation</a></h2>
<p>$$
{x}' =\sum_{j=1}^{m} w_iT_j (x+\delta (x,\theta ))
$$</p>
<ul>
<li>\({x}'= SKIN(PSD(x))\)</li>
<li>𝑃𝑆𝐷 is implemented as RBF interpolation</li>
<li>Example shapes can be created manually
<ul>
<li>Or by 3D scanning real people → the SMPL model</li>
</ul>
</li>
</ul>
<p>J. P. Lewis, Matt Cordner, and Nickson Fong. 2000. <strong>Pose space deformation: a unified approach to shape</strong></p>
<p><strong>interpolation and skeleton-driven deformation</strong>. In <em>Proceedings of the 27th annual conference on Computer</em></p>
<p><em>graphics and interactive techniques</em> (SIGGRAPH ’00), ACM Press/Addison-Wesley Publishing Co., USA, 165–172.</p>
<p>P86</p>
<h2 id="pose-space-deformation-1"><a class="header" href="#pose-space-deformation-1">Pose Space Deformation</a></h2>
<p><img src="./assets/07-31.png" alt="" /></p>
<p>P87</p>
<h2 id="issues"><a class="header" href="#issues">Issues</a></h2>
<ul>
<li>Per-shape or per-vertex interpolation
<ul>
<li>Should we interpolate a shape as a whole?</li>
</ul>
</li>
<li>Local or global interpolation?
<ul>
<li>Should a vertex be affected by all joints?</li>
</ul>
</li>
<li>Interpolation algorithm?
<ul>
<li>Is RBF the only choice?</li>
</ul>
</li>
</ul>
<p>SIGGRAPH Course 2014 — Skinning: Real-time Shape Deformation</p>
<p>P88</p>
<h2 id="example-based-skinning-ebs-vs-skeleton-subspace-deformation-ssd"><a class="header" href="#example-based-skinning-ebs-vs-skeleton-subspace-deformation-ssd">Example-based Skinning (EBS) vs. Skeleton Subspace Deformation (SSD)</a></h2>
<p>\(^\ast \)EBS: PSD<br />
\(\quad\)</p>
<ul>
<li>Good: Easy to control</li>
<li>Good: Good quality</li>
<li>Good: <strong>Pose-dependent details</strong> (e.g. bulging muscle and extruding veins)</li>
</ul>
<p>\(\quad\)</p>
<ul>
<li>Bad: Creating examples can be cumbersome</li>
<li>Bad: Extra storage for examples</li>
<li>Bad: Interpolation needs careful tuning</li>
</ul>
<p>\(\quad\)</p>
<p>\(^\ast \)SSD: LBS, DQS, etc.<br />
\(\quad\)</p>
<ul>
<li>Good: Easy to implement</li>
<li>Good: Fast and GPU friendly</li>
</ul>
<p>\(\quad\)</p>
<ul>
<li>Bad: Various artifacts</li>
<li>Bad: Skinning weights needs careful tuning</li>
<li>Bad: Hard to create pose-dependent details</li>
</ul>
<p>P89</p>
<h2 id="example-smpl-model"><a class="header" href="#example-smpl-model">Example: SMPL Model</a></h2>
<ul>
<li>A widely adopted human model in ML/CV</li>
<li>Learned on real scan data</li>
<li>Combines SSD and EBS techniques</li>
</ul>
<p><img src="./assets/07-32.png" alt="" /></p>
<p>P92</p>
<h2 id="recall-principal-component-analysis-pca"><a class="header" href="#recall-principal-component-analysis-pca">Recall: Principal Component Analysis (PCA)</a></h2>
<ul>
<li>Given a dataset {\(x_i\)}, \(x_i \in \mathbb{R} ^N\), then PCA gives</li>
</ul>
<p>$$
x_i=\bar{x}+\sum_{k=1}^{n} w_{i,k}u_k
$$</p>
<ul>
<li>\(u_k\) is the \(k\)-th principal component
<ul>
<li>A direction in \( \mathbb{R} ^N\) along which the rojection of {\(x_i\)} has the \(k\)-th maximal <strong>variance</strong></li>
</ul>
</li>
<li>\(w_{i,k}=(x_i-\bar{x})\cdot u_k\) is the score of \(x_i\) on \(u_k\)</li>
</ul>
<p>P93</p>
<h2 id="recall-principal-component-analysis-pca-1"><a class="header" href="#recall-principal-component-analysis-pca-1">Recall: Principal Component Analysis (PCA)</a></h2>
<p>• Given a dataset  {\(x_i\)}, \(x_i \in \mathbb{R} ^N\), the PCA can be computed by apply <strong>eigen decomposition</strong> on the covariance matrix</p>
<p>$$
\sum =X^TX=U\begin{bmatrix}
\sigma ^2_1 &amp;  &amp;  &amp; \\
&amp; \sigma ^2_2 &amp;  &amp; \\
&amp;  &amp; \ddots  &amp; \\
&amp;  &amp;  \sigma ^2_N
\end{bmatrix}U^T
$$</p>
<ul>
<li>
<p>\(X=[x_0-\bar{x}, x_1-\bar{x},\dots ,x_N-\bar{x}]^T\)</p>
</li>
<li>
<p>\(\sigma _i\ge \sigma _j\ge 0\) when \(i&lt; j\), corresponds to the Explained Variance</p>
</li>
<li>
<p>\(U=[u_1,u_2,\dots,u_N]\)</p>
</li>
</ul>
<p><img src="./assets/07-007.png" alt="" /></p>
<p>P94</p>
<h2 id="pca-over-body-shapes"><a class="header" href="#pca-over-body-shapes">PCA over Body Shapes</a></h2>
<p><img src="./assets/07-33.png" alt="" /></p>
<p>P95</p>
<h2 id="smpl-model-body-shape"><a class="header" href="#smpl-model-body-shape">SMPL Model: Body Shape</a></h2>
<p><img src="./assets/07-34.png" alt="" /></p>
<p>P96</p>
<h2 id="smpl-model-pose-blend-shapes"><a class="header" href="#smpl-model-pose-blend-shapes">SMPL Model: Pose Blend Shapes</a></h2>
<p><img src="./assets/07-35.png" alt="" /></p>
<p>P97</p>
<h2 id="smpl-model-deformation"><a class="header" href="#smpl-model-deformation">SMPL Model: Deformation</a></h2>
<p>$$
T(\beta ,\theta )=\bar{T} + \sum _ {m=1}^{|\beta |} \beta _ m S_ n + \sum _ {n=1}^{|\theta |}\theta _np_n
$$</p>
<p>$$
x=SKIN(T(\beta ,\theta ),\theta ,w)
$$</p>
<p>$$
SKIN:\text{LBS, DQS, etc}\dots 
$$</p>
<p><img src="./assets/07-36.png" alt="" /></p>
<p>[SMPL: A Skinned Multi-Person Linear Model]</p>
<p>P99</p>
<h2 id="facial-animation"><a class="header" href="#facial-animation">Facial Animation</a></h2>
<p><img src="./assets/07-37.png" alt="" /></p>
<p>P101</p>
<h2 id="facial-animation-1"><a class="header" href="#facial-animation-1">Facial Animation</a></h2>
<p><img src="./assets/07-38.png" alt="" /></p>
<blockquote>
<p>✅ \(B_j\) 与 ID 无关，能做出差不多的效果。<br />
✅ 要更精细的效果，可以定义与 ID 相关的 \(B_j\).</p>
</blockquote>
<p>P102</p>
<h2 id="facial-blendshapes"><a class="header" href="#facial-blendshapes">Facial Blendshapes</a></h2>
<p><img src="./assets/07-39.png" alt="" /></p>
<p>P103</p>
<h2 id="a-typical-set-of-blendshapes-arkit"><a class="header" href="#a-typical-set-of-blendshapes-arkit">A Typical Set of Blendshapes (ARKit)</a></h2>
<p><img src="./assets/07-40.png" alt="" /></p>
<p>P104</p>
<h2 id="blendshapes-vs-example-based-skinning"><a class="header" href="#blendshapes-vs-example-based-skinning">Blendshapes vs. Example-based Skinning</a></h2>
<p><img src="./assets/07-41.png" alt="" /></p>
<p><img src="./assets/07-42.png" alt="" /></p>
<p><img src="./assets/07-43.png" alt="" /></p>
<blockquote>
<p>✅ 几种不同的表情基混合方式。<br />
✅ 第二种，直接在几个脸之间做混合，适用于数据少的情况。</p>
</blockquote>
<p>P105</p>
<h2 id="morphable-face-models"><a class="header" href="#morphable-face-models">Morphable Face Models</a></h2>
<p><img src="./assets/07-44.png" alt="" /><br />
<img src="./assets/07-45.png" alt="" /></p>
<p>Egger et al. 2020. <strong>3D Morphable Face Models - Past, Present, and Future</strong>. <em>ACM Trans. Graph</em>. 39, 5 (June 2020), 157:1-157:38.</p>
<blockquote>
<p>✅ 第一项：平均脸。第二项：PCA. 第三项：表情基。<br />
✅ \(B_i^{ID}\) 通常由 PCA 得到。<br />
✅ 基于脸部肌肉的物理仿真。</p>
</blockquote>
<p>P107</p>
<h2 id="how-to-animate-a-face"><a class="header" href="#how-to-animate-a-face">How to Animate a Face?</a></h2>
<p><img src="./assets/07-47.png" alt="" /></p>
<p>P110</p>
<h2 id="face-tracking"><a class="header" href="#face-tracking">Face Tracking</a></h2>
<p><img src="./assets/07-48.png" alt="" /></p>
<blockquote>
<p>✅ 用一个视频人脸驱动 3D 人脸。<br />
✅ 人脸 \(\overset{①}{\rightarrow} \) 特征点  \(\overset{②}{\rightarrow} \) 表情参数<br />
✅ 1、提取    \(\quad\)   2、IK．</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P4</p>
<h1 id="physics-based-character-animation"><a class="header" href="#physics-based-character-animation">Physics-based Character Animation</a></h1>
<p>[ControlVAE – Yao et al. 2022]</p>
<blockquote>
<p>✅ 物理方法的难点：<br />
✅ (1) 仿真：在计算机中模拟出真实世界的运行方式。<br />
✅ (2) 控制：生成角色的动作，来做出响应。</p>
</blockquote>
<p>P5</p>
<h1 id="outline-7"><a class="header" href="#outline-7">Outline</a></h1>
<ul>
<li>Simulation Basis
<ul>
<li>Numerical Integration: Euler methods</li>
</ul>
</li>
<li>Equations of Rigid Bodies
<ul>
<li>Rigid Body Kinematics</li>
<li>Newton-Euler equations</li>
</ul>
</li>
<li>Articulated Rigid Bodies
<ul>
<li>Joints and constraints</li>
</ul>
</li>
<li>Contact Models
<ul>
<li>Penalty-based contact</li>
<li>Constraint-based contact</li>
</ul>
</li>
</ul>
<p><a href="https://www.cs.cmu.edu/%7Ebaraff/sigcourse/">https://www.cs.cmu.edu/~baraff/sigcourse/</a></p>
<blockquote>
<p>✅ 角色物体动画通常不关心仿真怎么实现。<br />
✅ 但也可以把仿真当成白盒，用模型的方法来实现。<br />
✅ 粒子运动模拟的部分跳过。P6-P22<br />
✅ 弹簧模拟跳过。P23-P27<br />
✅ 刚体模拟跳过。P28-P56</p>
</blockquote>
<p>P57</p>
<h1 id="kinematics-vs-dynamics"><a class="header" href="#kinematics-vs-dynamics">Kinematics vs. Dynamics</a></h1>
<p><img src="./assets/08-01.png" alt="" /></p>
<blockquote>
<p>✅ 运动学与动力学，主要区别在于有没有考虑角色质量。因为质量代表惯性，有惯性就不能瞬移。<br />
✅ 动力学基本概念跳过。P58-P89</p>
</blockquote>
<p>P91</p>
<h1 id="articulated-rigid-bodies"><a class="header" href="#articulated-rigid-bodies">Articulated Rigid Bodies</a></h1>
<h2 id="a-system-with-two-links"><a class="header" href="#a-system-with-two-links">A System with Two Links</a></h2>
<p><img src="./assets/08-02.png" alt="" /></p>
<blockquote>
<p>✅ 两个刚体的场景，如果两个刚体独立，可以以矩阵的方式扩展。<br />
✅ 物体在力的作用下的物理状态的更新公式．见 GAMES 103．<br />
✅ 每一行是独立的，联立起来为方程组。</p>
</blockquote>
<p>以上公式会简化为：</p>
<p>$$
M\dot{v} +C(x,v)=f
$$</p>
<blockquote>
<p>✅ 第二项是关于x和v的函数，x体现在\(\omega\)，v体现在I。</p>
</blockquote>
<p>P93</p>
<blockquote>
<p>✅ 结果是两个物体会分开。</p>
</blockquote>
<p><img src="./assets/08-03.png" alt="" /></p>
<p>P95</p>
<h2 id="a-system-with-two-links-and-a-joint"><a class="header" href="#a-system-with-two-links-and-a-joint">A System with Two Links and a Joint</a></h2>
<p><img src="./assets/08-04.png" alt="" /></p>
<p>$$
M\dot{v} +C(x,v)=f+f_J
$$</p>
<blockquote>
<p>✅ 两个物体中间有一个关节，约束两个物体不能分开。<br />
✅ 通过旋转力\(f_J\)的方法来保证约束，但 \(f_J\) 是未知的。</p>
</blockquote>
<p>P97</p>
<h3 id="constraints简化问题分析"><a class="header" href="#constraints简化问题分析">Constraints简化问题分析</a></h3>
<h4 id="问题描述-5"><a class="header" href="#问题描述-5">问题描述</a></h4>
<blockquote>
<p>✅ 假设有一约束：小球必须按轨道行进。</p>
</blockquote>
<p><img src="./assets/08-05-1.png" alt="" /></p>
<h4 id="小球速度分析"><a class="header" href="#小球速度分析">小球速度分析</a></h4>
<blockquote>
<p>✅ 根据已知条件，可以进行以下分析：由于每一时刻都满足，对时间求导，导数为零。</p>
</blockquote>
<p><img src="./assets/08-05-2.png" alt="" /></p>
<p>因此得到约束为：如果要求小球按照轨道运行，其速度必须满足以下公式。</p>
<p>P98 </p>
<p><img src="./assets/08-5.png" alt="" /></p>
<h4 id="小球的约束力分析"><a class="header" href="#小球的约束力分析">小球的约束力分析</a></h4>
<p>P99</p>
<blockquote>
<p>✅ 为了让小球满足约束，需给小球一个约束力。 </p>
</blockquote>
<p><img src="./assets/08-06.png" alt="" /></p>
<p>\(^\ast \) Constraint is passive No energy gain or loss!!!</p>
<p>$$
f_c\cdot v=0
$$</p>
<blockquote>
<p>✅ 约束力不应产生能量，即力与运动方向垂直。</p>
</blockquote>
<p>P100</p>
<p><img src="./assets/08-07.png" alt="" /></p>
<blockquote>
<p>✅ 结合是一页的结论可知：\(f_c\) 与 \(J\) 同方向，但大小未知。<br />
✅ \(f_c\) 大小以当前状态和外力情况计算而得。</p>
</blockquote>
<p>P101</p>
<h4 id="小球的整体受力分析"><a class="header" href="#小球的整体受力分析">小球的整体受力分析</a></h4>
<blockquote>
<p>✅ 对小球做受力分析，受到外力 \(f\) 和约束力 \(f_c\)．<br />
✅ 假设 \(M，x，v．f\) 已知，求 \(f_c\) ，使得小球沿轨迹移动。</p>
</blockquote>
<p><img src="./assets/08-08.png" alt="" /></p>
<p>$$
\begin{align*}
M\dot{v} &amp; =f+J^T\lambda  \\
Jv&amp;=0
\end{align*}
$$</p>
<blockquote>
<p>✅ 公式 1：\(f＝am\)．公式 2：前面推导得出。把两个公式离散化。<br />
✅ 因为公式 2 只约束了速度没有约束位置。离散化后对原公式只是近似，会有误差，导到小球远离曲线。</p>
</blockquote>
<p>$$
\begin{align*}
M\frac{v_{n+1}-v_n}{h}  &amp; =f+J^T\lambda  \\
Jv_{n+1}&amp;=0
\end{align*}
$$</p>
<blockquote>
<p>✅ 得出未知数为\(\lambda\)和\(v_{n+1}\)的联立方程组，求解方程组。<br />
✅ 解方程组不难，但存在小球偏离轨道的问题。</p>
</blockquote>
<p>P103</p>
<blockquote>
<p>✅ 当物体偏离轨道，要有拉回来的速度。因此公式2改为：</p>
</blockquote>
<p>$$
Jv_{n+1}=\alpha \frac{C-g(x_n)}{h} 
$$</p>
<p>Correction of numerical errors<br />
𝛼: error reduction parameter (ERP)</p>
<p>P104</p>
<h4 id="方程组求解"><a class="header" href="#方程组求解">方程组求解</a></h4>
<p><img src="./assets/08-09.png" alt="" /></p>
<blockquote>
<p>✅ 把ERP简写为 \(b\).<br />
✅ 为了防止矩阵不可逆，增加 \(\beta I\).（常见技巧）<br />
✅ 解 \(\lambda\) 需要先求逆。</p>
</blockquote>
<p>P105</p>
<h3 id="joint-constraint"><a class="header" href="#joint-constraint">Joint Constraint</a></h3>
<h4 id="约束方程"><a class="header" href="#约束方程">约束方程</a></h4>
<blockquote>
<p>✅ 前面是约束应用的简单例子，真正的问题是如何把约束应用到两个物体的连接约束上。</p>
</blockquote>
<p><img src="./assets/08-10.png" alt="" /></p>
<blockquote>
<p>✅ 因此设计约束：从 \(x_1\) 求 \(x_J\)位置 和从 \(x_2\) 求 \(x_J\)位置所得结果应该相同。</p>
</blockquote>
<p>$$
x_1+R_1r_1=x_J=x_2+R_2r_2
$$</p>
<p>对\(dt\)求导：</p>
<p>$$
v_1+\omega _1\times r_1=v_2+\omega _2\times r_2
$$</p>
<p>P106</p>
<blockquote>
<p>✅ 整理得矩阵形式，得：</p>
</blockquote>
<p>$$
\begin{bmatrix}
I_3 &amp; -[r_1] _ \times  &amp; -I_3 &amp; [r_2] _ \times 
\end{bmatrix}\begin{bmatrix}
v_1 \\
w_1 \\
v_2 \\
w_2
\end{bmatrix}=0
$$</p>
<blockquote>
<p>✅ 矩阵乘法第一项为 \(J\)，第二项为 \(v\). 进一步简化为：</p>
</blockquote>
<p>$$
Jv=0
$$</p>
<p>P107</p>
<h4 id="运动方程约束方程"><a class="header" href="#运动方程约束方程">运动方程+约束方程</a></h4>
<p>$$
\begin{align*}
M\dot{v} +C(x,v)&amp; =f+J^T\lambda  \\
Jv&amp;=0
\end{align*}
$$</p>
<blockquote>
<p>✅ 公式 1：运动方程。公式 2：约束方程。<br />
✅ 运动方程与约束方程联立。</p>
</blockquote>
<p>P109</p>
<h4 id="different-types-of-joints"><a class="header" href="#different-types-of-joints">Different Types of Joints</a></h4>
<blockquote>
<p>✅ 前面描述的是 Ball Joint的约束。</p>
</blockquote>
<p><img src="./assets/08-11.png" alt="" /></p>
<blockquote>
<p>✅ Hinge 约束：除了位置还有角速度约束，在某个轴上的角速度应当一致。Universal 类似。</p>
</blockquote>
<p>P110</p>
<h2 id="a-system-with-many-links-joints"><a class="header" href="#a-system-with-many-links-joints">A System with Many Links Joints</a></h2>
<p><img src="./assets/08-12.png" alt="" /></p>
<blockquote>
<p>✅ 分段多刚体在公式上没有本质区别，只是矩阵更大一点。</p>
</blockquote>
<p>P111</p>
<h1 id="contacts"><a class="header" href="#contacts">Contacts</a></h1>
<blockquote>
<p>✅ 如何处理与地面的接触，让人站在地面上。</p>
</blockquote>
<p><img src="./assets/08-13.png" alt="" /></p>
<blockquote>
<p>✅ 要解决的问题：(1) 地面接触检测 (2) 如何对碰撞点施加力，使物体出来。</p>
</blockquote>
<p>P114</p>
<h2 id="penalty-based-contact-model"><a class="header" href="#penalty-based-contact-model">Penalty-based Contact Model</a></h2>
<h3 id="baseline"><a class="header" href="#baseline">Baseline</a></h3>
<p><img src="./assets/08-14.png" alt="" /></p>
<p>$$
f_n=-k_pd-k_dv_{c,\perp }
$$</p>
<blockquote>
<p>✅ 类似弹簧形式，陷入越深，力越大。<br />
✅ 第二项：为了防止落地弹飞，增加阻尼项。<br />
✅ 效果：会有一些陷入，但不会陷入太多</p>
</blockquote>
<p>P115</p>
<h3 id="考虑摩擦力"><a class="header" href="#考虑摩擦力">考虑摩擦力</a></h3>
<p><img src="./assets/08-15.png" alt="" /></p>
<blockquote>
<p>✅ 受力分析：支持力，动摩擦力。<br />
✅ 动摩擦力，大小＝支持力 x 摩擦系数，方向与运动方向相反</p>
</blockquote>
<p>$$
\begin{align*}
f_t&amp;=-\mu f_n\frac{v_{c,\parallel }}{||v_{c,\parallel }||} 
\end{align*}
$$</p>
<blockquote>
<p>✅ 一般不模拟静摩擦力</p>
</blockquote>
<p>P116</p>
<h3 id="存在的问题"><a class="header" href="#存在的问题">存在的问题</a></h3>
<blockquote>
<p>✅ 存在的问题：\(K_p\) 必须很大，否则脚陷地明显，步长必须非常小，否则不稳定。</p>
</blockquote>
<p>P118</p>
<h2 id="contact-as-a-constraint"><a class="header" href="#contact-as-a-constraint">Contact as a Constraint</a></h2>
<blockquote>
<p>✅ 另一种方法，把接触建模为约束。</p>
</blockquote>
<h3 id="接触点状态分析"><a class="header" href="#接触点状态分析">接触点状态分析</a></h3>
<p><img src="./assets/08-17.png" alt="" /></p>
<p>$$
x_c  =x+r_c \quad\quad\quad\quad\quad\quad
$$</p>
<p>$$
v_c  =v+\omega \times r_c=J_c \begin{bmatrix}
v\\
w
\end{bmatrix}
$$</p>
<p>$$
v_{c,\perp } =v+\omega \times r_c=J_{c,\perp  }\begin{bmatrix}
v \\
\omega 
\end{bmatrix}
$$</p>
<p>P120</p>
<h3 id="接触点约束分析"><a class="header" href="#接触点约束分析">接触点约束分析</a></h3>
<p><img src="./assets/08-19.png" alt="" /></p>
<p>$$
v_c\perp \lambda =0
$$</p>
<blockquote>
<p>✅ 约束 1：点在竖直方向的速度必须大于 0，即只能向上移动。<br />
✅ 约束 2：力的大小也大于 0．只能推，不能拉。<br />
✅ 约束 3：力和速度只能有一个不为零，否则会做功。合在一起称为线性互补方程，是通常碰撞建模方式。<br />
✅ 这个方程比较难解，例如 ODE</p>
</blockquote>
<p>这类问题被称为：(Mixed) Linear Complementary Problem (LCP)<br />
解LCP的方法有：<br />
e.g. Lemke's algorithm – a simplex algorithm</p>
<p>P122</p>
<h3 id="考虑摩擦力的约束问题"><a class="header" href="#考虑摩擦力的约束问题">考虑摩擦力的约束问题</a></h3>
<p>How to deal the friction?</p>
<blockquote>
<p>🔎 Fast contact force computation for nonpenetrating rigid bodies.<br />
David Baraff. SIGGRAPH ’94<br />
✅ 快速实现静摩擦约束的建模。</p>
</blockquote>
<p>P123</p>
<h1 id="simulation-of-a-rigid-body-system"><a class="header" href="#simulation-of-a-rigid-body-system">Simulation of a Rigid Body System</a></h1>
<p><img src="./assets/08-18.png" alt="" /></p>
<blockquote>
<p>✅ 把人简化为分段刚体。整体过程为：<br />
✅ (1) 黄：计算当前状态。<br />
✅ (2) 绿：计算约束，求解，解出下一时刻的速度。<br />
✅ (3) 蓝：更新下一时刻的量（积分）。<br />
✅ 缺少部分：主动力 \(f\) 推动角色产生运动。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline-8"><a class="header" href="#outline-8">Outline</a></h1>
<ul>
<li>
<p>Simulating &amp; Actuating Characters</p>
<ul>
<li>Joint torques</li>
</ul>
</li>
<li>
<p>PD (Proportional-Derivative) control</p>
</li>
</ul>
<blockquote>
<p>✅ 在仿真基础之上，如何驱动角色动画，如何动得更好，更真实。<br />
✅（1）控制力如何施加到角色身上<br />
✅（2）如何计算控制力</p>
</blockquote>
<p>P4</p>
<h1 id="recap"><a class="header" href="#recap">Recap</a></h1>
<h2 id="dynamics-of-a-point-mass"><a class="header" href="#dynamics-of-a-point-mass">Dynamics of a Point Mass</a></h2>
<p><img src="./assets/09-01.png" alt="" /></p>
<p>P10</p>
<h2 id="rigid-body-dynamics"><a class="header" href="#rigid-body-dynamics">Rigid Body Dynamics</a></h2>
<p><img src="./assets/09-02.png" alt="" /></p>
<p>$$
\begin{bmatrix}
mI_3 &amp; 0\\
0 &amp; I
\end{bmatrix}\begin{bmatrix}
\dot{v}  \\
\dot{\omega }
\end{bmatrix}+\begin{bmatrix}
0\\
\omega \times I\omega 
\end{bmatrix}=\begin{bmatrix}
f \\
\tau 
\end{bmatrix}
$$</p>
<p>P12</p>
<p>Masses: \(m,I\)<br />
Kinematics:  \(x,v,R,\omega \)</p>
<p>Geometry:<br />
• Box, Sphere, Capsule, Mesh, …<br />
• Collision detection<br />
• Compute \(m,I\)</p>
<blockquote>
<p>✅ 在物理引擎里面定义一个刚体，需要提供这些参数。</p>
</blockquote>
<p>P14</p>
<h2 id="dynamics-of-articulated-rigid-bodies"><a class="header" href="#dynamics-of-articulated-rigid-bodies">Dynamics of Articulated Rigid Bodies</a></h2>
<p><img src="./assets/09-04.png" alt="" /></p>
<blockquote>
<p>✅ 两个独立刚体，和一个不让它们断开的约束。</p>
</blockquote>
<p>P15</p>
<p>$$
M\dot{v} +C(x,v)  =f+J^T\lambda
$$</p>
<p>P16</p>
<h2 id="simulation-of-a-rigid-body-system-1"><a class="header" href="#simulation-of-a-rigid-body-system-1">Simulation of a Rigid Body System</a></h2>
<p><img src="./assets/09-05.png" alt="" /></p>
<h1 id="simulating--actuating-characters"><a class="header" href="#simulating--actuating-characters">Simulating &amp; Actuating Characters</a></h1>
<p>P17</p>
<h2 id="defining-a-simulated-character"><a class="header" href="#defining-a-simulated-character">Defining a Simulated Character</a></h2>
<p>Rigid bodies:</p>
<ul>
<li>\(m_i,I_i,x_i,R_i\)</li>
<li>Geometries</li>
</ul>
<p>Joints:</p>
<ul>
<li>Position</li>
<li>Type</li>
</ul>
<blockquote>
<p>✅ Type指关节的类型，例如 Hint、Universal等。它决定了约束方程。</p>
</blockquote>
<ul>
<li>Bodies</li>
</ul>
<blockquote>
<p>✅ 关节的数量比刚体的数量少1</p>
</blockquote>
<p><img src="./assets/09-06.png" alt="" /></p>
<blockquote>
<p>✅ 仿真过程中通常使用简单几何体代替 Mesh. 为了便于碰撞检测的计算，以及辨别里外。</p>
</blockquote>
<p>P19</p>
<h2 id="simulating-a-character-pipeline"><a class="header" href="#simulating-a-character-pipeline">Simulating a Character Pipeline</a></h2>
<p><img src="./assets/09-07.png" alt="" /></p>
<blockquote>
<p>✅ 这个仿真流程是 ragdoll 效果。</p>
</blockquote>
<p>P22</p>
<h2 id="actuating-a-rigid-body"><a class="header" href="#actuating-a-rigid-body">Actuating a Rigid Body</a></h2>
<blockquote>
<p>✅ 想让角色做指定动作，不能直接修改其状态，而是控制力影响状态。</p>
</blockquote>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>力加在质心上</td><td><img src="./assets/09-08.png" alt="" /></td></tr>
<tr><td>✅ 在物体边缘旋加力，等价于在质心旋加力，并旋加一个导致旋转的力矩。</td><td><img src="./assets/09-09.png" alt="" /><br><img src="./assets/09-10.png" alt="" /></td></tr>
<tr><td>✅ 在质心上施加一个力矩，等价于施加一对大小相同方向相反的力。在质心处的合力为零，不会产生位移，只会产生旋转。<br> ✅ 力矩只是数学上的概念。</td><td><img src="./assets/09-11.png" alt="" /></td></tr>
</tbody></table>
<p>P26</p>
<h2 id="actuating-articulated-rigid-bodies"><a class="header" href="#actuating-articulated-rigid-bodies">Actuating Articulated Rigid Bodies</a></h2>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>✅ 为了驱动角色，可以单独对每个刚体施加力或力矩。</td><td><img src="./assets/09-12.png" alt="" /></td></tr>
<tr><td>✅ 也可以在关节上施加力矩。</td><td><img src="./assets/09-13.png" alt="" /></td></tr>
</tbody></table>
<p>P29</p>
<h2 id="joint-torques"><a class="header" href="#joint-torques">Joint Torques</a></h2>
<p>What is a joint torque?<br />
How is a joint torque applied?</p>
<blockquote>
<p>✅ 回顾前面公式，力和力矩都是施加在刚体上的，如何施加在关节上?</p>
</blockquote>
<p>P33</p>
<h3 id="什么是joint-torques"><a class="header" href="#什么是joint-torques">什么是Joint Torques</a></h3>
<blockquote>
<p>✅ 关节上的力矩，可以看作是一个刚体对另一个刚体在关节处施加的成对的力，其合力为零，但可以转化为对另一刚体的力矩。</p>
</blockquote>
<p><img src="./assets/09-014.png" alt="" /></p>
<p>$$
\sum_{i}^{} f_i=0
$$</p>
<blockquote>
<p>✅ 每个力都会对其中一个刚体的质心上产生力矩。</p>
</blockquote>
<p>$$
\tau _1= \sum _ {i}^{} (r_1+r_i) \times f_i=r_1 \times \sum _ {i}^{}f_i + \sum _ {i}^{}r_i \times f_i
$$</p>
<p>P34<br />
由于</p>
<p>$$
\sum _ {i}^{}  f_i=0
$$</p>
<p>得： </p>
<p>$$
\tau _1= \sum _ {i}^{} r_i \times f_i \quad \quad \quad \quad \tau _2= -\sum _ {i}^{} r_i \times f_i
$$</p>
<blockquote>
<p>✅ 另一个方向同理。<br />
✅ 力矩跟关节的内置没有关系。</p>
</blockquote>
<p>P36<br />
结论：</p>
<p><img src="./assets/09-16.png" alt="" /></p>
<blockquote>
<p>✅ 在关节上施加力矩 \( \tau\) 等价于在一个刚体上施加 \( \tau\)，在另一个刚体上施加 \(- \tau\).</p>
</blockquote>
<p>P38</p>
<h3 id="怎样施加joint-torques"><a class="header" href="#怎样施加joint-torques">怎样施加Joint Torques</a></h3>
<p>Applying a joint torque \( \tau\):</p>
<ul>
<li>Add \( \tau\) to one attached body</li>
<li>Add \( -\tau\) to the other attached body</li>
</ul>
<p>$$
M\begin{bmatrix}
\dot{v}_1 \\
\dot{\omega }_1 \\
\dot{v}_2\\
\dot{\omega }_2 
\end{bmatrix} + \begin{bmatrix}
0\\
\omega_1 \times I_1 \omega _1\\
0\\
\omega_2 \times I_2 \omega _2
\end{bmatrix}=\begin{bmatrix}
0 \\
\tau \\
0 \\
-\tau 
\end{bmatrix}+J^T\lambda 
$$</p>
<p>$$
Jv=0
$$</p>
<blockquote>
<p>✅ 通常在子关节上加 \(\tau \)，在父关节上加 \(-\tau \)． </p>
</blockquote>
<p>P40</p>
<h2 id="simulating--controlling-a-character"><a class="header" href="#simulating--controlling-a-character">Simulating + Controlling a Character</a></h2>
<p><img src="./assets/09-17.png" alt="" /></p>
<blockquote>
<p>✅ 控制器，根据当前角色状态，以及额外控制信号实时计算出 \(f \) 和 \(\tau \)，影响角色动作变化。</p>
</blockquote>
<p>P44</p>
<h3 id="forward-dynamics-vs-inverse-dynamics"><a class="header" href="#forward-dynamics-vs-inverse-dynamics">Forward Dynamics vs. Inverse Dynamics</a></h3>
<p><img src="./assets/09-18.png" alt="" /></p>
<blockquote>
<p>✅ 前向与后向，是一个运动方程的两种用法。<br />
✅ 仿真器为前向部分，控制后逆向部分。</p>
</blockquote>
<p>P46</p>
<h3 id="fully-actuated-vs-underactuated"><a class="header" href="#fully-actuated-vs-underactuated">Fully-Actuated vs. Underactuated</a></h3>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/09-20.png" alt="" /></td><td><img src="./assets/09-21.png" alt="" /></td></tr>
<tr><td>If #actuators ≥ #dofs, the system is <strong>fully-actuated</strong></td><td>If #actuators &lt; #dofs, the system is <strong>underactuated</strong></td></tr>
<tr><td>For any \([x,v,\dot{v} ]\), there exists an \(f\) that produces the motion</td><td>For many \([x,v,\dot{v} ]\) , there is no such \(f\) that produces the motion</td></tr>
<tr><td>✅ 可以精确控制机械臂到达目标状态。</td><td>✅ 不借助外力情况，人无法控制 Hips 的状态（位置）。</td></tr>
</tbody></table>
<blockquote>
<p>✅ ＃actuators：\(f \) 和 \(\tau \) 的自由度。<br />
✅ #dofs：角色状态的自由度。<br />
✅ 避免让角色掉入无法控制的状态。</p>
</blockquote>
<p>P49</p>
<h3 id="feedforward-vs-feedback"><a class="header" href="#feedforward-vs-feedback">Feedforward vs. Feedback</a></h3>
<p><img src="./assets/09-22.png" alt="" /></p>
<table><thead><tr><th>Feedforward control</th><th>Feedback control</th></tr></thead><tbody>
<tr><td>\(f,\tau =\pi (t)\)</td><td>\(f,\tau =\pi (s_t,t)\)</td></tr>
<tr><td>Apply predefined control signals <strong>without considering the current state</strong> of the system</td><td>Adjust control signals based on the current state of the system</td></tr>
<tr><td>Assuming unchanging system.</td><td>Certain perturbations are expected.</td></tr>
<tr><td>Perturbations may lead to unpredicted results<br>✅ 如果角色受到挠动而偏离了原计划，无法修正回来。</td><td>The feedback signal will be used to improves the performance at the next state.</td></tr>
</tbody></table>
<p>P55</p>
<h1 id="proportional-derivative-control"><a class="header" href="#proportional-derivative-control">Proportional-Derivative Control</a></h1>
<blockquote>
<p>✅ 有反馈，但还是算是前向控制，因为反馈的部分和想控制的部分不完全一致。</p>
</blockquote>
<h2 id="简化问题分析"><a class="header" href="#简化问题分析">简化问题分析</a></h2>
<h3 id="问题描述-6"><a class="header" href="#问题描述-6">问题描述</a></h3>
<p>Compute force \(f\) to move the object to the target height</p>
<blockquote>
<p>✅ 例子：物体只能沿竿上下移动，且受到重力。<br />
✅ 控制目的：设计控制器，使物体在控制力的作用下达到目标高度。</p>
</blockquote>
<p><img src="./assets/09-23-1.png" alt="" /></p>
<h3 id="使用比例控制"><a class="header" href="#使用比例控制">使用比例控制</a></h3>
<p><img src="./assets/09-23-2.png" alt="" /></p>
<p>实际上：会产生上下振荡，不会停在目标位置。</p>
<p><img src="./assets/09-23.png" alt="" /></p>
<p>P56</p>
<h3 id="比例控制damping"><a class="header" href="#比例控制damping">比例控制+Damping</a></h3>
<p><img src="./assets/09-24.png" alt="" /></p>
<blockquote>
<p>✅ 改进：如果物体已有同方向速度，则力加得小一点。</p>
</blockquote>
<p>P57</p>
<h3 id="比例微分控制"><a class="header" href="#比例微分控制">比例微分控制</a></h3>
<p><img src="./assets/09-24-1.png" alt="" /></p>
<blockquote>
<p>✅ 第一项：比例控制；第二项：微分控制</p>
</blockquote>
<p>P59</p>
<blockquote>
<p>✅ 存在的问题：为了抵抗重力，一定会存在这样的误差。</p>
</blockquote>
<p><img src="./assets/09-26.png" alt="" /></p>
<p>P60</p>
<p>Increase stiffness \(k_p\) reduces the steady-state error, but can make the system too stiff and numerically unstable</p>
<blockquote>
<p>✅ 增加 \(k_p\) 可以减小误差，但会让人看起来很僵硬。</p>
</blockquote>
<p>P61</p>
<h3 id="比例积分微分控制-proportional-integral-derivative-controller"><a class="header" href="#比例积分微分控制-proportional-integral-derivative-controller">比例积分微分控制 Proportional-Integral-Derivative controller</a></h3>
<p><img src="./assets/09-27.png" alt="" /><br />
<img src="./assets/09-28.png" alt="" /></p>
<blockquote>
<p>✅ 解决误差方法：积分项。<br />
✅ 但角色动画通常不用积分项。<br />
✅ 积分项跟历史相关，会带来实现的麻烦和控制的不稳定。</p>
</blockquote>
<p>P62</p>
<h2 id="pd-control-for-characters"><a class="header" href="#pd-control-for-characters">PD Control for Characters</a></h2>
<blockquote>
<p>✅ 前面是 PD 的例子，这里是 PD 在物理仿真角色上的应用，计算在每个关节上施加多少力矩。</p>
</blockquote>
<p><img src="./assets/09-29.png" alt="" /></p>
<p><img src="./assets/09-30.png" alt="" /></p>
<blockquote>
<p>✅ 通常目标的速度 \(\bar{q} = 0\).</p>
</blockquote>
<p>因此：<br />
<img src="./assets/09-31.png" alt="" /></p>
<p>P63</p>
<h3 id="pd-control-for-characters的参数和效果"><a class="header" href="#pd-control-for-characters的参数和效果">PD Control for Characters的参数和效果</a></h3>
<blockquote>
<p>✅ \(K_p\) 太小：可能无法达到目标状态。<br />
✅ \(K_p\) 太大：人体很僵硬。<br />
✅ \(k_d\) 太小：动作有明显振荡。<br />
✅ \(k_d\) 太大，要花更多时间到达目标资态。</p>
</blockquote>
<p>P66</p>
<h2 id="tracking-controllers-1"><a class="header" href="#tracking-controllers-1">Tracking Controllers</a></h2>
<blockquote>
<p>✅ 引入PD Control之后，控制本质上变成了设计 targer state．</p>
</blockquote>
<p><img src="./assets/09-32.png" alt="" /></p>
<p>P67</p>
<h3 id="full-body-tracking-controllers"><a class="header" href="#full-body-tracking-controllers">Full-body Tracking Controllers</a></h3>
<p><img src="./assets/09-33.png" alt="" /></p>
<blockquote>
<p>✅ 设计角色的目标轨迹。<br />
✅ 直接用 PD 控制跟踪动捕数据会有很大的问题，原因：<br />
（1）稳态误差。<br />
（2）运动轨迹跟原轨迹之间会相差一点点相位<br />
（3）欠驱动系统，有一点点误差，后面无法修复。</p>
</blockquote>
<p>P71</p>
<h3 id="feedforward--feedback"><a class="header" href="#feedforward--feedback">feedforward ？ feedback</a></h3>
<p>Is PD control a <strong>feedforward</strong> control?<br />
a <strong>feedback</strong> control?</p>
<blockquote>
<p>✅ 是反馈控制，因为计算 \(\tau \) 时使用了当前状态 \(q\)．<br />
✅ 是前馈控制，因为在 PD 系统里，状态是位置不是 \(q\).</p>
</blockquote>
<p>P72</p>
<h2 id="欠驱动系统"><a class="header" href="#欠驱动系统">欠驱动系统</a></h2>
<h3 id="欠驱动系统的问题"><a class="header" href="#欠驱动系统的问题">欠驱动系统的问题</a></h3>
<p>由于是欠驱动系统，Tracking Mocap with Joint Torques会遇到问题，因为：</p>
<p>\(\tau _j\): joint torques<br />
Apply \(\tau _j\) to “child” body<br />
Apply \(-\tau _j\) to “parent” body<br />
<strong>All forces/torques sum up to zero</strong></p>
<blockquote>
<p>✅ 合力为零，无法控制整体的位置和朝向。</p>
</blockquote>
<p>P73</p>
<h3 id="解决方法增加净外力"><a class="header" href="#解决方法增加净外力">解决方法：增加净外力</a></h3>
<p>\(f_0,\tau _0\): root force / torque<br />
\(\quad\quad\)Apply \(f_0\) to the root body<br />
\(\quad\quad\)Apply \(\tau _0\) to the root body<br />
\(\quad\quad\)Non-zero net force/torque on the character!</p>
<blockquote>
<p>✅ 净外力，无施力者，用于帮助角色保持平衡。<br />
✅ 缺点：让角色看起来像提线木偶。</p>
</blockquote>
<p>P75</p>
<h2 id="mixture-simulation-and-mocap"><a class="header" href="#mixture-simulation-and-mocap">Mixture Simulation and Mocap</a></h2>
<p><img src="./assets/09-34.png" alt="" /></p>
<blockquote>
<p>✅ 关键帧与仿真的混合。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline-9"><a class="header" href="#outline-9">Outline</a></h1>
<ul>
<li>
<p>More about PD (Proportional-Derivative) control</p>
<ul>
<li>Stable PD control</li>
</ul>
</li>
<li>
<p>Feedforward Motion Control</p>
<ul>
<li>Trajectory optimization</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 不通过施加净外力，构建物理准确的动画。</p>
</blockquote>
<ul>
<li>Feedback Motion Control
<ul>
<li>Static balance</li>
</ul>
</li>
</ul>
<p>P3</p>
<h1 id="pd-control-for-characters-1"><a class="header" href="#pd-control-for-characters-1">PD Control for Characters</a></h1>
<h2 id="基本方法"><a class="header" href="#基本方法">基本方法</a></h2>
<p><img src="./assets/10-01.png" alt="" /></p>
<p><img src="./assets/10-02.png" alt="" /></p>
<p>P4</p>
<h3 id="存在的问题-1"><a class="header" href="#存在的问题-1">存在的问题</a></h3>
<p>PD control computes torques based on <strong>errors</strong></p>
<h4 id="steady-state-error"><a class="header" href="#steady-state-error">Steady state error</a></h4>
<p>This arm never reaches the target angle under gravity</p>
<p><img src="./assets/10-03.png" alt="" /></p>
<p>P5</p>
<h4 id="motion-falls-behind-the-reference"><a class="header" href="#motion-falls-behind-the-reference">Motion falls behind the reference</a></h4>
<p><img src="./assets/10-04.png" alt="" /></p>
<p>P7</p>
<h4 id="稳定性"><a class="header" href="#稳定性">稳定性</a></h4>
<blockquote>
<p>✅ 前面两个问题的根本原因是相同的，因为需要有误差才能计算force，有了force才能控制。</p>
</blockquote>
<p>High-gain \((k_p)\) control is more precise but less stable…</p>
<blockquote>
<p>✅ 增大 \(k_p\)能缓解以上问题，但大的 \(k_p\) 会带来肢体僵硬和计算不稳定。</p>
</blockquote>
<p>P8</p>
<h2 id="stability-of-pd-control"><a class="header" href="#stability-of-pd-control">Stability of PD Control</a></h2>
<h3 id="以弹簧系统为例子"><a class="header" href="#以弹簧系统为例子">以弹簧系统为例子</a></h3>
<p><img src="./assets/10-05.png" alt="" /></p>
<p>$$
\begin{matrix}
f=-k_px-k_dv \quad\quad\quad\\
h: \text{ simulation time step}
\end{matrix}
$$</p>
<blockquote>
<p>✅ PD control 的过程类似于一个弹簧系统。<br />
✅ 因此利用弹簧系统中的半隐式欧拉来提升 PD 的稳定性。</p>
</blockquote>
<h3 id="半隐式欧拉的弹簧系统"><a class="header" href="#半隐式欧拉的弹簧系统">半隐式欧拉的弹簧系统</a></h3>
<p>Semi-implicit Euler Integration</p>
<p>$$
\begin{align*}
v_{n+1}  &amp; =v_n+h\frac{f}{m} \\
x_{n+1} &amp;=x_n+hv_{n+1}
\end{align*}
$$</p>
<h3 id="半隐式欧拉的pd控制"><a class="header" href="#半隐式欧拉的pd控制">半隐式欧拉的PD控制</a></h3>
<blockquote>
<p>✅ \(h\) 为时间步长。<br />
✅ (1) 假设 \(m＝1\) (2) 代入 \(f\) 到方程组 (3) 方程组写成矩阵形式，得：</p>
</blockquote>
<p>P11</p>
<p>$$
\begin{bmatrix}
v_{n+1}\\
x_{n+1}
\end{bmatrix}=\begin{bmatrix}
1-k_dh  &amp; -k_ph\\
h(1-k_dh) &amp; 1-k_ph^2
\end{bmatrix}\begin{bmatrix}
v_n \\
x_n
\end{bmatrix}
$$</p>
<p>P14<br />
提取常数方程A，得：</p>
<p>$$
A=\begin{bmatrix}
1-k_dh  &amp; -k_ph\\
h(1-k_dh) &amp; 1-k_ph^2
\end{bmatrix}
$$</p>
<p><img src="./assets/10-06.png" alt="" /></p>
<p>P19</p>
<h3 id="pd控制的稳定性"><a class="header" href="#pd控制的稳定性">PD控制的稳定性</a></h3>
<p>\(\lambda _1,\lambda _2 \in  \mathbb{C}  \) are eigenvalues of \(A\)</p>
<blockquote>
<p>✅ 基于中间变是 \(z_n\) 推导的过程跳过。<br />
✅ 根据矩阵特征值的性质可直接得出结论。</p>
</blockquote>
<p>if \(|\lambda _1|&gt; 1\)</p>
<p>The system is unstable!</p>
<p>Condition of stability: \(|\lambda _i|\le  1 \text{ for all } \lambda _i\)</p>
<p>P20</p>
<h3 id="通过h控制pd控制的稳定性"><a class="header" href="#通过h控制pd控制的稳定性">通过h控制PD控制的稳定性</a></h3>
<p><img src="./assets/10-07.png" alt="" /></p>
<blockquote>
<p>✅ 如果 \(k_p\) 和 \(k_d\) 变大，就必须以一个较小的时间步长进行仿真。</p>
</blockquote>
<h3 id="pd-control-for-characters-2"><a class="header" href="#pd-control-for-characters-2">PD Control for Characters</a></h3>
<p>P21</p>
<ul>
<li>
<p>Determining gain and damping coefficients can be difficult…</p>
<ul>
<li>A typical setting \(k_p\) = 200, \(k_d\) = 20 for a 50kg character</li>
<li>Light body requires smaller gains</li>
<li>Dynamic motions need larger gains</li>
</ul>
</li>
<li>
<p>High-gain/high-damping control can be unstable, so small times is necessary</p>
<ul>
<li>\(h\) = 0.5~1ms is often used, or 1000~2000Hz</li>
<li>Higher gain/damping requires smaller time step</li>
</ul>
</li>
</ul>
<p>P22</p>
<h2 id="a-more-stable-pd-control"><a class="header" href="#a-more-stable-pd-control">A More Stable PD Control</a></h2>
<h3 id="半隐式欧拉--隐式欧拉"><a class="header" href="#半隐式欧拉--隐式欧拉">半隐式欧拉 → 隐式欧拉</a></h3>
<blockquote>
<p>✅ 解决方法：半隐式欧拉 → 隐式欧拉，即用下一时刻的力计算下一时刻的速度。</p>
</blockquote>
<ul>
<li>半隐式欧拉</li>
</ul>
<p>$$
\begin{align*}
v_{n+1} &amp; = v_n+h(-k_px_n-k_dv_n) \\
v_{n+1} &amp; = x_n+hv_{n+1}
\end{align*}
$$</p>
<p>$$
\Downarrow 
$$</p>
<ul>
<li>隐式欧拉</li>
</ul>
<p>$$
\begin{align*}
v_{n+1} &amp; = v_n+h(-k_px_n-k_dv_{n+1}) \\
x_{n+1} &amp; = x_n+hv_{n+1}
\end{align*}
$$</p>
<blockquote>
<p>✅ 实际上，计算 \(f_{n＋1}\) 只使用 \(V_{n＋1}\) , 不使用 \(x_{n＋1}\) , 因为 \(x_{n＋1}\) 会引入非常复杂的计算。<br />
✅ 由于 \(v_{n＋1}\) 未知，需通过解方程组来求解。</p>
</blockquote>
<p>P23<br />
得到的方程组为：</p>
<p>$$
\begin{bmatrix}
v_{n+1} \\
x_{n+1} 
\end{bmatrix}=\frac{1}{1+hk_d} \begin{bmatrix}
1 &amp; -k_ph\\
h &amp; 1+k_dh-k_ph^2
\end{bmatrix}\begin{bmatrix}
v_n\\
x_n
\end{bmatrix}
$$</p>
<p>P24</p>
<h3 id="稳定性分析"><a class="header" href="#稳定性分析">稳定性分析</a></h3>
<p><img src="./assets/10-08.png" alt="" /></p>
<blockquote>
<p>✅ \(v_{n}\) 换成 \(v_{n＋1}\) ，很大承度上提高了稳定性。</p>
</blockquote>
<p>P25</p>
<h3 id="相关工作-3"><a class="header" href="#相关工作-3">相关工作</a></h3>
<blockquote>
<p>🔎 <img src="./assets/10-09.png" alt="" /></p>
</blockquote>
<p>$$
\tau _{\mathrm{int} }=-K_p(q^n+\dot{q}^n \Delta t-\bar{q} ^{n+1})-K_d(\dot{q} ^n+\ddot{q} ^n \Delta t)
$$</p>
<p>P26</p>
<h3 id="pd-control-for-characters-3"><a class="header" href="#pd-control-for-characters-3">PD Control for Characters</a></h3>
<ul>
<li>
<p>Determining gain and damping coefficients can be difficult…</p>
<ul>
<li>A typical setting \(k_p\) = 200, \(k_d\) = 20 for a 50kg character</li>
<li>Light body requires smaller gains</li>
<li>Dynamic motions need larger gains</li>
</ul>
</li>
<li>
<p>High-gain/high-damping control can be unstable, so small times is necessary</p>
<ul>
<li>\(h\) = 0.5~1ms is often used, or 1000~2000Hz</li>
<li>\(h\) = 1/120s~1/60s, or 120Hz/60Hz <strong>with Stable PD</strong></li>
<li>Higher gain/damping requires smaller time step</li>
</ul>
</li>
</ul>
<p>P28</p>
<h1 id="tracking-mocap-with-root-forcestorques"><a class="header" href="#tracking-mocap-with-root-forcestorques">Tracking Mocap with Root Forces/Torques</a></h1>
<blockquote>
<p>✅ 当前系统仍存的问题。(1) 稳态误差，相位延迟 (2) 缺少对根结点的力。</p>
</blockquote>
<p><img src="./assets/10-10.png" alt="" /></p>
<p>\(\tau _j\): joint torques<br />
\(\text{ }\) Apply \(\tau _j\) to “child” body<br />
\(\text{ }\) Apply \(-\tau _j\) to “parent” body<br />
\(\text{ }\) All forces/torques sum up to zero</p>
<p>\(f_0,\tau _0\): root force / torque</p>
<p>\(\quad\quad\) Apply \(f _0\) to the root body</p>
<p>\(\quad\quad\) Apply \(\tau _0\) to the root body</p>
<p>\(\quad\quad\) Non-zero net force/torque on the character!</p>
<blockquote>
<p>✅ 净外力能解决问题 2，但会有“提线木偶”的 artifacts.<br />
✅ 解决方法：不直接学习目标轨迹，而是先对目标轨迹增加一个修正。即轨迹优化。</p>
</blockquote>
<p>P30</p>
<h2 id="trajectory-optimization"><a class="header" href="#trajectory-optimization">Trajectory Optimization</a></h2>
<blockquote>
<p>🔎 [Witkin and Kass 1988 – Spacetime constraints]</p>
</blockquote>
<blockquote>
<p>✅ 轨迹优化的问题描述：</p>
</blockquote>
<p>Find the trajectories:</p>
<p>$$
\begin{align*}
\text{Simulation trajectory } &amp; : S_0,S_1,\dots ,S_T \\
\text{Control trajectory } &amp; : a_0,a_1,\dots ,a_{T-1}
\end{align*}
$$</p>
<blockquote>
<p>✅ \(S\)：每一个时刻，角色的状态，包括位置、速度、朝向等。<br />
✅ \(a\)：目标轨迹。<br />
✅ 优化出 \(S\) 和 \(a\)，根据 \(S\) 和 \(a\) 得到关节力矩，关节力矩再控制角色。</p>
</blockquote>
<p>that minimize the objective function</p>
<p>$$
\min_{(S_t,a_t)} f(S_T)+\sum_{t=0}^{T-1} f(S_t,a_t)
$$</p>
<blockquote>
<p>✅ 目标函数第一项：关于轨迹结束时刻的状态。<br />
✅ 第二项：关于每一时刻的状态。</p>
</blockquote>
<p>and satisfy the constraints:</p>
<p>$$
\begin{align*}
M\dot{v}+C(x,v)   &amp; =f+J^T\lambda &amp; \text{Equations of motion} \\
g(x,v) &amp; \ge 0 &amp; \text{constraints } \quad \quad\quad
\end{align*}
$$</p>
<blockquote>
<p>✅ 约束第一项：运动学方程。<br />
✅ 第二项：根据场景特殊定义的约束。</p>
</blockquote>
<p>P33 </p>
<h2 id="简化问题分析-1"><a class="header" href="#简化问题分析-1">简化问题分析</a></h2>
<blockquote>
<p>✅ 仍以方块移动到目标高度为例。</p>
</blockquote>
<h3 id="问题描述-7"><a class="header" href="#问题描述-7">问题描述</a></h3>
<p><img src="./assets/10-11.png" alt="" /></p>
<p>Compute a target trajectory \(\tilde{x} (t)\) such that the simulated trajectory \(x(t)\) is a sine curve.</p>
<h3 id="目标函数"><a class="header" href="#目标函数">目标函数</a></h3>
<p>$$
\min_ {(x_n,v_n,\tilde {x} _n)} \sum _ {n=0}^{N} (\sin (t_n)-x_n)^2+\sum _ {n=0}^{N} \tilde {x}^2_n 
$$</p>
<blockquote>
<p>✅ 目标函数：目标项＋正则项</p>
</blockquote>
<h3 id="约束"><a class="header" href="#约束">约束</a></h3>
<p>$$
\begin{align*}
s.t. \quad &amp; v _ {n+1}= v_ n+h (k _ p( \tilde {x} _n-x_n)-k _ dv_n) \\
&amp; v _ {n+1} = x _ n + hv _ {n+1}
\end{align*}
$$</p>
<blockquote>
<p>✅ 约束：半隐式积分的运动方程</p>
</blockquote>
<p>P34</p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Hard constraints:</td><td><img src="./assets/10-12.png" alt="" /></td></tr>
<tr><td>Soft constraints:</td><td><img src="./assets/10-013.png" alt="" /></td></tr>
</tbody></table>
<blockquote>
<p>✅ 以两种方式体现约束：<br />
✅（1）Hard：必须满足，难解，不稳定。<br />
✅（2）Soft：尽可能满足，易求解。</p>
</blockquote>
<p>P35</p>
<h3 id="参数简化"><a class="header" href="#参数简化">参数简化</a></h3>
<p>Collocation methods:</p>
<p>Assume the optimization variables {\(x_n, v_n, \tilde{x}_n\)} are values of a set of parametric curves</p>
<ul>
<li>typically polynomials or splines</li>
</ul>
<p>Optimize the parameters of the curves \(\theta\) instead</p>
<ul>
<li>with smaller number of variables than the original problem</li>
</ul>
<blockquote>
<p>✅ 要优化的参数量太大，难以优化。<br />
✅ 解决方法：假设参数符合特定的曲线，只学习曲线的参数，再生成完整的参数。</p>
</blockquote>
<p>P37</p>
<h3 id="优化方法"><a class="header" href="#优化方法">优化方法</a></h3>
<p>How to solve this optimization problem?<br />
Gradient-based approaches:</p>
<ul>
<li>Gradient descent</li>
<li>Newton’s methods</li>
<li>Quasi-Newton methods</li>
<li>……</li>
</ul>
<p>P39</p>
<h2 id="trajectory-optimization-for-tracking-control"><a class="header" href="#trajectory-optimization-for-tracking-control">Trajectory Optimization for Tracking Control</a></h2>
<p><img src="./assets/10-14.png" alt="" /></p>
<p>find a target trajectory</p>
<p><img src="./assets/10-15.png" alt="" /></p>
<blockquote>
<p>✅ 把动捕结果当成初始解，然后以优化的方式找到合理轨迹。</p>
</blockquote>
<p>P40</p>
<h3 id="problem-with-gradient-based-methods"><a class="header" href="#problem-with-gradient-based-methods">Problem with Gradient-Based Methods</a></h3>
<ul>
<li>The optimization problem is usually <strong>highly nonlinear</strong>, gradients are unreliable</li>
<li>The system is a black box with unknow dynamics, gradients are not available</li>
</ul>
<p>解决方法： Derivative-Free Optimization</p>
<ul>
<li>
<p>Iterative methods</p>
<ul>
<li>Goal: find the variables 𝒙 that optimize \(f(x)\)</li>
<li>Determining an initial guess of \(x\)</li>
<li>Repeat:
<ul>
<li>Propose a set of candidate variables {\(x_i\)} according to \(x\)</li>
<li>Evaluate the objective function \(f_i=f(x_i)\)</li>
<li>Update the estimation for \(x\)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Examples:</p>
<ul>
<li>Bayesian optimization, Evolution strategies (e.g. CMA-ES), Stochastic optimization, Sequential Monte Carlo methods, ……</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 启发式方法或随机采样方法，不需要梯度。<br />
✅ 缺点：慢、不精确。</p>
</blockquote>
<p>P43</p>
<h3 id="cma-es"><a class="header" href="#cma-es">CMA-ES</a></h3>
<ul>
<li>Covariance matrix adaptation evolution strategy (CMA-ES)
<ul>
<li>A widely adopted derivative-free method in character animation</li>
</ul>
</li>
</ul>
<p><img src="./assets/10-17.png" alt="" /></p>
<p>Goal: find the variables 𝒙 that optimize \(f(x)\) </p>
<ul>
<li>Initialize Gaussian distribution \(x\sim \mathcal{N} (\mu ,\Sigma )\)</li>
<li>Repeat:
<ul>
<li>sample candidate variables {\(x_i\)} \( \sim \mathcal{N} (\mu ,\Sigma )\)</li>
<li>Evaluate the objective function \(f_i=f(x_i)\)
<ul>
<li>Involve simulation and generate simulation trajectories</li>
</ul>
</li>
<li>Sort {\(f_i\)} and keep the top \(N\) elite samples</li>
<li>Update \(\mu ,\Sigma \) according to the elite samples</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 优点：稳定，无梯度，可用于黑盒系统。</p>
</blockquote>
<p>P44</p>
<blockquote>
<p>🔎 [Wampler and Popović 2009 - Optimal Gait and Form for Animal Locomotion]</p>
</blockquote>
<p>P45</p>
<blockquote>
<p>✅ [Al Borno et al. 2013 - Trajectory Optimization for Full-Body Movements with Complex Contacts]</p>
</blockquote>
<blockquote>
<p>✅ 只优化目标轨迹，不优化仿真轨迹。因为仿真轨迹可以通仿真得到。</p>
</blockquote>
<p>P46</p>
<h3 id="samcon"><a class="header" href="#samcon">SAMCON</a></h3>
<blockquote>
<p>✅ CMA-ES 的缺点：<br />
（1）每次都从头到尾做仿真，计算量大。<br />
（2）如果仿真轨迹长，则难收敛。<br />
✅ 改进方法：每次采样，只考虑下面一帧。</p>
</blockquote>
<blockquote>
<p>🔎 <strong>SA</strong>mpling-based <strong>M</strong>otion <strong>CON</strong>trol [Liu et al. 2010, 2015]<br />
- Motion Clip → Open-loop control trajectory<br />
- A sequential Monte-Carlo method</p>
</blockquote>
<p><img src="./assets/10-18.png" alt="" /></p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/10-19.png" alt="" /></td><td>✅ 把轨迹分割开，每次优化一小段。</td></tr>
<tr><td><img src="./assets/10-20.png" alt="" /></td><td>✅ 在目标轨迹上增加偏移，跟踪偏移之后的轨迹。<br> ✅ 偏移量未知，因此以高斯分布对偏移量采样。  <br> ✅ 高斯分布可由其它分布代替。</td></tr>
<tr><td><img src="./assets/10-21.png" alt="" /></td><td>✅ 对每个偏移量做一次仿真，生成新的状态，保留其中与当目标接近的 N 个。</td></tr>
<tr><td><img src="./assets/10-22.png" alt="" /></td><td>✅ 从上一步 N 个中随机选择出发点，以及随机的偏移量，再做仿真与筛选。</td></tr>
<tr><td><img src="./assets/10-23.png" alt="" /></td><td>✅ 最终找到一组最接近的。   <br> ✅ 原理：只选一个容易掉入局部最优，因此保留多个。 <br>  ✅ 蒙特卡罗＋动态规划</td></tr>
</tbody></table>
<blockquote>
<p>✅ 优点：穿膜问题也能被修正掉，可还原动捕数据，可根据环境影响而自动调整。</p>
</blockquote>
<p>P54</p>
<h1 id="feedforward--feedback-control"><a class="header" href="#feedforward--feedback-control">Feedforward &amp; Feedback Control</a></h1>
<h2 id="feedforward-control"><a class="header" href="#feedforward-control">Feedforward Control</a></h2>
<p><img src="./assets/10-24.png" alt="" /></p>
<blockquote>
<p>✅ 前馈控制，要求每一步的起始状态都是在获取轨迹过程中能得到的状态。<br />
✅ 如果对起始状态加一点挠动，状态会偏离很远。</p>
</blockquote>
<p>P56</p>
<h2 id="feedback-control"><a class="header" href="#feedback-control">Feedback Control</a></h2>
<blockquote>
<p>✅ 解决方法：引入反馈策略。根据当前偏差，自动计算出更正，把更正叠加到控制轨迹上。</p>
</blockquote>
<table><thead><tr><th></th></tr></thead><tbody>
<tr><td><img src="./assets/10-025.png" alt="" /></td></tr>
<tr><td><img src="./assets/10-026.png" alt="" /></td></tr>
<tr><td><img src="./assets/10-027.png" alt="" /></td></tr>
</tbody></table>
<p>P62</p>
<h1 id="static-balance"><a class="header" href="#static-balance">Static Balance</a></h1>
<h2 id="定义-3"><a class="header" href="#定义-3">定义</a></h2>
<p>What is balance?</p>
<blockquote>
<p>✅ Static Balance：在不发生移动的情况下，通过简单的控制策略，保证角色不摔倒。<br />
✅ 平衡：质心在支撑面内。</p>
</blockquote>
<p>P64<br />
<img src="./assets/10-29.png" alt="" /></p>
<blockquote>
<p>✅ 人的质心：每一段的质心的加权平均。<br />
✅ 人的支撑面：两脚之内。</p>
</blockquote>
<p>P66 </p>
<h2 id="a-simple-strategy-pd-control"><a class="header" href="#a-simple-strategy-pd-control">A simple strategy： PD Control</a></h2>
<p>A simple strategy to maintain balance:</p>
<h3 id="根据条件计算力矩"><a class="header" href="#根据条件计算力矩">根据条件计算力矩</a></h3>
<ul>
<li>
<p>Keep projected CoM close to the center of support polygon <strong>while tracking a standing pose</strong></p>
</li>
<li>
<p>Use <strong>PD control</strong> to compute feedback torque</p>
</li>
</ul>
<p><img src="./assets/10-30.png" alt="" /></p>
<blockquote>
<p>✅ 力矩 1：让角色保持某个姿势。<br />
✅ 力矩 2：让质心与目标质心位置接近。<br />
✅ 在某些关节上增加一些额外的力矩。</p>
</blockquote>
<p>P68</p>
<h3 id="施加力矩"><a class="header" href="#施加力矩">施加力矩</a></h3>
<ul>
<li>Apply the feedback torque at <strong>ankles</strong> (ankle strategy) or <strong>hips</strong> (hip strategy)</li>
</ul>
<p>P69</p>
<h2 id="jacobian-transpose-control"><a class="header" href="#jacobian-transpose-control">Jacobian Transpose Control</a></h2>
<blockquote>
<p>✅ 实现 static balance，除了 PD 控制还有其它方法。</p>
</blockquote>
<h3 id="计算要施加的力"><a class="header" href="#计算要施加的力">计算要施加的力</a></h3>
<p><img src="./assets/10-32.png" alt="" /></p>
<p>Can we use joint torques \(\tau _i\) to mimic the effect of a force \(f\) applied at \(x\)</p>
<ul>
<li>Note that the <strong>desired force</strong> \(f\) is not actually applied</li>
<li>Also called <strong>“virtual force”</strong></li>
</ul>
<blockquote>
<p>✅ 通过施加 \(\tau _1 ，\tau _2，\tau _3\) 来达到给 \(x\) 施加 \(f\) 的效果！</p>
</blockquote>
<p>P73</p>
<h3 id="把力转化为力矩"><a class="header" href="#把力转化为力矩">把力转化为力矩</a></h3>
<p>Make \(f\) and \(\tau _i\) done the same power</p>
<p>$$
P=f^T\dot{x}=\tau  ^T\dot{\theta } 
$$</p>
<blockquote>
<p>✅ 从做功的角度。功率 = fv</p>
</blockquote>
<p>Forward kinematics \(x=g(\dot{\theta } )\Rightarrow \dot{x}=J \dot{\theta } \)</p>
<blockquote>
<p>✅ \(g（* ）\) 是一个FK函数。其中：<br />
$$
J=\frac{\partial g}{\partial \theta } 
$$<br />
✅ 把 \( \dot{x } \) 代入上面公式得</p>
</blockquote>
<p>$$
f^T J\dot{\theta } = \tau  ^T\dot{\theta } 
$$</p>
<p>$$
\Downarrow 
$$</p>
<p>P76</p>
<p>$$
\tau =J^Tf
$$</p>
<blockquote>
<p>✅ 把 \( \tau\) 分解为每一个关节每一个旋转的 \( \tau\)．通过 Jacobian 矩阵的含义推出：</p>
</blockquote>
<p>$$
\Downarrow 
$$</p>
<p>$$
\tau _i=(x-p_i)\times f
$$</p>
<p>P77</p>
<h3 id="用于static-balance"><a class="header" href="#用于static-balance">用于Static Balance</a></h3>
<p>A simple strategy to maintain balance:</p>
<ul>
<li>
<p>Keep projected CoM close to the center of support polygon <strong>while tracking a standing pose</strong></p>
</li>
<li>
<p>Use PD control to compute feedback <strong>virtual force</strong></p>
</li>
</ul>
<blockquote>
<p>✅ P66 中在 Hips 上加力矩的方式只能进行简单的控制。<br />
✅ 可以通过虚力实现相似的效果。</p>
</blockquote>
<p>$$
f=k_p(\bar{c} -c)-k_d\dot{c}
$$</p>
<blockquote>
<p>✅ \(c\) 不一定是投影距离，还可以描述高度距离，实现站起蹲下的效果。</p>
</blockquote>
<p>P78</p>
<ul>
<li>Assuming \(f\) <strong>is applied to the CoM</strong>, compute necessary joint torques using Jacobian transpose control to achieve it</li>
</ul>
<blockquote>
<p>✅ 但也不是真的加力，而是通过前面讲的 Jacobian transpose control 方法转为特定关节的力矩。</p>
</blockquote>
<ul>
<li>Usually using the joints in the legs</li>
</ul>
<blockquote>
<p>✅ 最后达到在Hips上加力的效果<br />
✅ 但这种方式能施加的力非常弱，只能实现比较微弱的平衡</p>
</blockquote>
<p>P79</p>
<h2 id="a-fancier-strategy"><a class="header" href="#a-fancier-strategy">A fancier strategy:</a></h2>
<ul>
<li>Mocap tracking as an objective function</li>
<li>Controlling both the CoM position/<strong>momentum</strong> and the <strong>angular</strong> momentum</li>
<li>Solve a <strong>one-step</strong> optimization problem to compute joint torques</li>
</ul>
<blockquote>
<p>🔎 <img src="./assets/10-34.png" alt="" /></p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline-10"><a class="header" href="#outline-10">Outline</a></h1>
<ul>
<li>
<p>Walking and Dynamic Balance</p>
</li>
<li>
<p>Simplified Models</p>
<ul>
<li>ZMP (Zero-Moment Point)</li>
<li>Inverted Pendulum</li>
<li>SIMBICON</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 不能直接控制角色位置，而是通过与地面的力和反作用力。</p>
</blockquote>
<p>P3</p>
<h1 id="walking"><a class="header" href="#walking">Walking</a></h1>
<p><img src="./assets/11-01.png" alt="" /></p>
<p><img src="./assets/11-02.png" alt="" /></p>
<blockquote>
<p>🔎 <strong>Gait disorders in adults and the elderly</strong>.<br />
phases of a walking gait cycle<br />
Pirker and Katzenschlager 2017.</p>
</blockquote>
<p>P4</p>
<h2 id="walking-vs-running"><a class="header" href="#walking-vs-running">Walking VS Running</a></h2>
<table><thead><tr><th>Walking</th><th>Running</th></tr></thead><tbody>
<tr><td><img src="./assets/11-04.png" alt="" /><br>Walking: move without <em>loss of contact</em>, or flight phases</td><td><img src="./assets/11-05.png" alt="" /></td></tr>
</tbody></table>
<p>P7</p>
<h2 id="walking的几个阶段"><a class="header" href="#walking的几个阶段">Walking的几个阶段</a></h2>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/11-6.png" alt="" /></td><td><img src="./assets/11-7.png" alt="" /></td></tr>
<tr><td><img src="./assets/11-08.png" alt="" /></td><td><img src="./assets/11-09.png" alt="" /></td></tr>
<tr><td><img src="./assets/11-10.png" alt="" /></td><td><img src="./assets/11-11.png" alt="" /></td></tr>
</tbody></table>
<blockquote>
<p>✅ 以上过程假设角色处于 static 状态。没有考虑到移动过程中的脚的动量。因此只能勉强保持角色稳定。要以非常慢的速度相前移动。</p>
</blockquote>
<p>P11</p>
<h1 id="zero-moment-point-zmp"><a class="header" href="#zero-moment-point-zmp">Zero-Moment Point (ZMP)</a></h1>
<blockquote>
<p>✅ 通过ZMP的控制实现比较稳定的走路。</p>
</blockquote>
<h2 id="全身受力分析与问题简化"><a class="header" href="#全身受力分析与问题简化">全身受力分析与问题简化</a></h2>
<p><img src="./assets/11-12.png" alt="" /></p>
<blockquote>
<p>✅ 角色受到重力和GRF力。<br />
✅ GRF ＝ 支持力（向上）＋ 动摩擦力（有速度时才有）<br />
✅ 简化：上半身受到的所有的力，都体现在 ankle 关节上。</p>
</blockquote>
<p>P12</p>
<h3 id="recall-a-system-of-links-and-joints"><a class="header" href="#recall-a-system-of-links-and-joints">Recall: A System of Links and Joints</a></h3>
<p><img src="./assets/11-13.png" alt="" /></p>
<p>$$
M\dot{v} +C(x,v)=f+f_J
$$</p>
<blockquote>
<p>✅ 在满足这个公式的前提下，一个部分动了另一个部分就会跟着动。因此可以把问题简化，只分析ankle。</p>
</blockquote>
<p>P15</p>
<h2 id="脚上受力分析"><a class="header" href="#脚上受力分析">脚上受力分析</a></h2>
<p><img src="./assets/11-14.png" alt="" /></p>
<blockquote>
<p>✅ 仅分析脚上的力，\(f_{\text{ankle}}\) 为 ankle 上的力转化到脚上的力。</p>
</blockquote>
<p><img src="./assets/11-15.png" alt="" /></p>
<blockquote>
<p>✅ 地面对脚的力不是施加到某一个点上，但可以根据公式换算成施加到某一点的力。</p>
</blockquote>
<p>P17</p>
<p>Assuming the ground is flat and level<br />
so \(p_i\) - \(p\)  is always in the horizontal plane</p>
<p><img src="./assets/11-16.png" alt="" /></p>
<blockquote>
<p>✅ 把 \(\tau _{GRF} \) 分解为与地面垂直部分和与地面平行部分（力矩的方向是指它的旋转轴的方向。），其中垂直的部分为：</p>
</blockquote>
<p><img src="./assets/11-1.png" alt="" /></p>
<p>水平的部分为： </p>
<p><img src="./assets/11-17.png" alt="" /></p>
<p><strong>Can we find \(p\) such that \(\tau _{GRF}^{xz}=0\) ?</strong></p>
<p>P21</p>
<h2 id="zero-moment-point-zmp-1"><a class="header" href="#zero-moment-point-zmp-1">Zero-Moment Point (ZMP)</a></h2>
<p><img src="./assets/11-18.png" alt="" /></p>
<p>当\(p\) 为 center pressure时：</p>
<p>$$
\begin{align*}
f_{GRF}  &amp; =\sum _{i}^{} f_i \\
\tau _{GRF} &amp; =\tau _{GRF}^y=\sum _{i}^{}(p_i-p)\times f_i^{xz}
\end{align*}
$$</p>
<p>The position of \(p\) is not known, but we assume 以上公式成立。</p>
<h2 id="zmp条件下支撑脚的受力分析"><a class="header" href="#zmp条件下支撑脚的受力分析">ZMP条件下支撑脚的受力分析</a></h2>
<p>假设： 支撑脚 should not move in a <strong>stance phase</strong>，且支撑脚与地面完成接触<br />
则：在所有力作用下处于静平衡状态。</p>
<p><img src="./assets/11-20.png" alt="" /></p>
<p>Static Equilibrium:</p>
<p>静态平衡满足：所有合力为0</p>
<p>$$
f_{\text{ankle}} + f_{\text{GRF}} + mg = 0<br />
$$</p>
<p>静态平衡满足：任选一个参考点，所有合力（力矩）相对于参考点的动量为0，否则会旋转。</p>
<p>The moment around a reference point \(o\):</p>
<p>$$
(u-o) \times f_{\text{ankle}} + (p-o) \times f_{\text{GRF}} + (x-o)\times mg + \tau _{GRF}^{y} + \tau _{\text{ankle}} = 0
$$</p>
<blockquote>
<p>✅ \(o\) 是一个参考点，可以在任意位置<br />
✅ U：ankle 位置。<br />
✅ X：质心位置
✅ P：位置未知，高度为 0．</p>
</blockquote>
<p>同样只关心水平方向：</p>
<p>Horizontal components (moment projected onto \(xz\) plane):</p>
<p>$$
((u-o) \times f_{\text{ankle}})^{xz} +( (p-o) \times f_{\text{GRF}} ) ^{xz}+ (x-o)\times mg + \tau _{\text{ankle}}^{xz} = 0
$$</p>
<blockquote>
<p>✅ 总力矩为 0，否则人会旋转。</p>
</blockquote>
<p>P28</p>
<h2 id="求解-zero-moment-point-zmp"><a class="header" href="#求解-zero-moment-point-zmp">求解 Zero-Moment Point (ZMP)</a></h2>
<p>We can solve this equation to find \(p\)</p>
<p>\(p\) is <strong>called Zero-Moment Point (ZMP)</strong> because it makes</p>
<p>$$
\tau _{GRF}^{xz}=0
$$</p>
<p>and the horizontal moment</p>
<p>$$
((u-o) \times f_{\text{ankle}})^{xz} +( (p-o) \times f_{\text{GRF}} ) ^{xz}+ (x-o)\times mg + \tau _{\text{ankle}}^{xz} = 0
$$</p>
<p>Only when 𝑝 is <strong>within the support polygon</strong>!</p>
<blockquote>
<p>✅ \(p\) 满足（1）水平力矩为0. （2）人整体上平衡。<br />
✅ \(u，O，X\) 都是已知，\(p\) 的高度为 0，只有 \(P_xP_y\) 未知且该公式分别在 \(X\) 和 \(Z\) 上成立，实际上是两个方程。<br />
✅ 两个未知量和两个方程，可以解出 \(p\)。</p>
</blockquote>
<p>P33</p>
<p>如果解出公式得到的\(p\) is outside the support polygon，那么：<br />
\(p\) could NOT be the center of pressure, because all the GRFs 
are applied within the polygon, so that</p>
<p>$$
\tau _{GRF}^{xz}\ne 0
$$</p>
<blockquote>
<p>✅ 如果求出 \(p\) 在 polygon外 则不能平衡，因为不是 center pressure.</p>
</blockquote>
<p>如果选择polygon上的real center of pressure\({p}' \) ,那么：</p>
<p>$$
((u-o) \times f_{\text{ankle}})^{xz} +( ({p}'-o) \times f_{\text{GRF}} ) ^{xz}+ (x-o)\times mg + \tau _{\text{ankle}}^{xz} \ne 0
$$</p>
<blockquote>
<p>✅ \({p}' \ne p\)，\({p}'\) 处水平方向的合外力不为零，脚会翻转人会摔倒。</p>
</blockquote>
<h1 id="simplified-models"><a class="header" href="#simplified-models">Simplified Models</a></h1>
<p>P35</p>
<h2 id="关于zmp的思考"><a class="header" href="#关于zmp的思考">关于ZMP的思考</a></h2>
<p>The existence of ZMP is an indication of dynamic balance We can achieve balanced walking by controlling ZMP But how?</p>
<p>P36</p>
<h2 id="simplified-models的基本套路"><a class="header" href="#simplified-models的基本套路">Simplified Models的基本套路</a></h2>
<ul>
<li>Simplify humanoid / biped robot into an abstract model
<ul>
<li>Often consists of a CoM and a massless mechanism</li>
<li>Need to map the state of the robot to the abstract model</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 因此，把最影响平衡的量拿出来，建立简化模型。<br />
✅ 实际上更加复杂，对上半身任何一个部位的干挠，都会影响到脚上的力。</p>
</blockquote>
<ul>
<li>
<p>Plan the control and movement of the model</p>
<ul>
<li>Optimization</li>
<li>Dynamic programming</li>
<li>Optimal control</li>
<li>MPC</li>
</ul>
</li>
<li>
<p>Track the planned motion of the abstract model</p>
<ul>
<li>Inverse Kinematics</li>
<li>Inverse Dynamics</li>
</ul>
</li>
</ul>
<p><img src="./assets/11-23.png" alt="" /></p>
<p>P37</p>
<h2 id="example-zmp-guided-control"><a class="header" href="#example-zmp-guided-control">Example: ZMP-Guided Control</a></h2>
<blockquote>
<p>🔎 <img src="./assets/11-25.png" alt="" /></p>
</blockquote>
<p><img src="./assets/11-26-1.png" alt="" /></p>
<blockquote>
<p>✅ 把机器人简化为桌子和小车，通过控制小车m的运动来控制 ZMP。使 ZMP 满足预定义轨迹。</p>
</blockquote>
<p><img src="./assets/11-26.png" alt="" /></p>
<blockquote>
<p>✅ 预定义轨迹的轨迹是指保持在pologon里面。通过优化得到 \(m\) 的运动。<br />
✅ 然后通过IK和PD control控制脚的运动。</p>
</blockquote>
<blockquote>
<p>✅ ASIMO机器人局限性：(1) 脚必须与地面平行。 (2) 脚必须弯曲。 (3) 整体移动速度慢。</p>
</blockquote>
<p>P40</p>
<h2 id="inverted-pendulum-model-ipm"><a class="header" href="#inverted-pendulum-model-ipm">Inverted Pendulum Model (IPM)</a></h2>
<p><strong>Walking == Falling + Step Planning</strong></p>
<blockquote>
<p>✅ 人的特点是重心偏离再拉回来，这样比始终保持平更省。</p>
</blockquote>
<p>P42</p>
<h3 id="ipm问题"><a class="header" href="#ipm问题">IPM问题</a></h3>
<blockquote>
<p>✅ IPM： 倒立摆模型，控制小车使杆不掉下去。</p>
</blockquote>
<p><img src="./assets/11-27-1.png" alt="" /></p>
<h3 id="step-plan-with-ipm"><a class="header" href="#step-plan-with-ipm">Step Plan with IPM</a></h3>
<blockquote>
<p>🔎 <img src="./assets/11-28.png" alt="" /></p>
</blockquote>
<p>P45</p>
<ul>
<li>Map CoM of the character and the stance foot as IPM</li>
<li>Plan the position of the next foot step so that the mass point rests at the top of the pendulum</li>
<li>Create foot trajectory based on the step plan</li>
<li>Compute target poses using IK</li>
</ul>
<p><img src="./assets/11-29.png" alt="" /></p>
<blockquote>
<p>✅ 脚到重心是一个倒立摆。<br />
✅ 由于失去平衡，质心有一个向前的速度，通过到一个合适的落脚点，使质心到达脚的正上方刚好到达速度稳定。<br />
✅ 算出脚的目标位置后，插值，IK，PD 控制。</p>
</blockquote>
<p>P46</p>
<p><img src="./assets/11-30.png" alt="" /></p>
<blockquote>
<p>✅ 动能转势能，能量守恒．算出高度。<br />
❗ 注意：杆的长度是不确定的，因为腿会弯曲。</p>
</blockquote>
<p>P47</p>
<blockquote>
<p>✅ 方法优点：可以适用于不同角色，不同动作，不同环境交互。</p>
</blockquote>
<p>P48</p>
<h2 id="simbicon-1"><a class="header" href="#simbicon-1">SIMBICON</a></h2>
<blockquote>
<p>🔎 SIMBICON (SIMple BIped Locomotion CONtrol) Yin et al. 2007</p>
</blockquote>
<p><img src="./assets/11-31.png" alt="" /></p>
<blockquote>
<p>✅ 经典工作，第一个实现了鲁棒的步态控制。<br />
✅ 原理：跟踪控制器上加一个反馈</p>
</blockquote>
<p>P49</p>
<h3 id="step-1"><a class="header" href="#step-1">Step 1</a></h3>
<ul>
<li>Step 1: develop a cyclical base motion
<ul>
<li>PD controllers track target angles</li>
<li>FSM (Finite State Machine) or mocap</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 本质上是一个跟踪控制器，用状态机来实现的跟踪控制器</p>
</blockquote>
<p><img src="./assets/11-32.png" alt="" /></p>
<blockquote>
<p>✅ 有四个状态，通过跟踪在4个状态之间切换，也可以用动捕数据来代替</p>
</blockquote>
<p>P50</p>
<h3 id="step-2"><a class="header" href="#step-2">Step 2</a></h3>
<ul>
<li>Step 2:
<ul>
<li>control torso and swing-hip wrt world frame</li>
</ul>
</li>
</ul>
<p><img src="./assets/11-33.png" alt="" /></p>
<blockquote>
<p>✅ 控制目标：上半身保持竖直。<br />
✅ 控制方法：<br />
通过保持上半身竖直，计算出\(\tau _{\text{torso}} \)。<br />
通过使B跟踪目标动作，计算出\(\tau _{B} \)。<br />
通过 \(\tau _{\text{torso}} \) 和 \(\tau _{B} \) 控制 \(\tau _{A} \).</p>
</blockquote>
<p>P51</p>
<h3 id="step-3"><a class="header" href="#step-3">Step 3</a></h3>
<ul>
<li>Step 3: COM feedback</li>
</ul>
<p><img src="./assets/11-34.png" alt="" /></p>
<blockquote>
<p>✅ 估计下一个脚步的位置d，使质心处于可控范围内。<br />
✅ \(d\) 与 \(D\) 有关，但关系复杂，在此处做了简化。</p>
</blockquote>
<p>P52</p>
<p><img src="./assets/11-35.png" alt="" /></p>
<blockquote>
<p>✅ 简化问题：\(d\) 和 \(v\) 与 \(\theta _d\) 的速度是线性关系。速度会转化为 PD 目标的修正。<br />
✅ 线性的系数为手调。</p>
</blockquote>
<p>P53</p>
<h3 id="simbicon-2"><a class="header" href="#simbicon-2">SIMBICON</a></h3>
<p><img src="./assets/11-36.png" alt="" /></p>
<p>P54</p>
<h2 id="outline-11"><a class="header" href="#outline-11">Outline</a></h2>
<ul>
<li>How to generalize to other motion?</li>
</ul>
<p><img src="./assets/11-37.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="outline-12"><a class="header" href="#outline-12">Outline</a></h1>
<ul>
<li>
<p>Optimal Control</p>
</li>
<li>
<p>Model-based Approaches vs. Model-free Approaches</p>
</li>
<li>
<p>Sampling-based Optimization</p>
</li>
<li>
<p>Reinforcement Learning</p>
</li>
<li>
<p>Conclusion</p>
</li>
</ul>
<p>P3</p>
<h2 id="recap-1"><a class="header" href="#recap-1">Recap</a></h2>
<table><thead><tr><th>feedforward</th><th>feedback</th></tr></thead><tbody>
<tr><td><img src="./assets/12-01.png" alt="" /></td><td><img src="./assets/12-04.png" alt="" /></td></tr>
<tr><td><img src="./assets/12-02.png" alt="" /></td><td><img src="./assets/12-03.png" alt="" /></td></tr>
</tbody></table>
<blockquote>
<p>✅ 开环控制：只考虑初始状态。<br />
✅ 前馈控制：考虑初始状态和干挠。<br />
✅ 前馈控制优化的是轨迹。<br />
✅ 反馈控制优化的是控制策略，控制策略是一个函数，根据当前状态优化轨迹。</p>
</blockquote>
<p>P9</p>
<p><img src="./assets/12-05.png" alt="" /></p>
<blockquote>
<p>✅ Feedback 类似构造一个场，把任何状态推到目标状态。</p>
</blockquote>
<p>P10</p>
<h1 id="开环控制"><a class="header" href="#开环控制">开环控制</a></h1>
<h2 id="问题描述-8"><a class="header" href="#问题描述-8">问题描述</a></h2>
<p>$$
\begin{matrix}
\min_{x}  f(x)\\
𝑠.𝑡. g(x)=0
\end{matrix}
$$</p>
<p><img src="./assets/12-06.png" alt="" /></p>
<p>P12</p>
<h2 id="把硬约束转化为软约束"><a class="header" href="#把硬约束转化为软约束">把硬约束转化为软约束</a></h2>
<p>$$
\min_{x}  f(x)+ wg(x)
$$</p>
<p>\(^\ast \) The solution \(x^\ast\)  may not satisfy the constraint</p>
<p>P16</p>
<h2 id="lagrange-multiplier---把约束条件转化为优化"><a class="header" href="#lagrange-multiplier---把约束条件转化为优化">Lagrange Multiplier - 把约束条件转化为优化</a></h2>
<blockquote>
<p>✅ 拉格朗日乘子法。</p>
</blockquote>
<p><img src="./assets/12-08.png" alt="" /></p>
<blockquote>
<p>✅ 通过观察可知，极值点位于\({f}'(x)\) 与 \(g\) 的切线垂直，即 \({f}' (x)\) 与 \({g}' (x)\) 平行。（充分非必要条件。）</p>
</blockquote>
<p>因此：</p>
<p><img src="./assets/12-07.png" alt="" /></p>
<p>Lagrange function</p>
<p>$$
L(x,\lambda )=f(x)+\lambda ^Tg(x)
$$</p>
<blockquote>
<p>✅ 把约束条件转化为优化。</p>
</blockquote>
<p>P18</p>
<h2 id="lagrange-multiplier"><a class="header" href="#lagrange-multiplier">Lagrange Multiplier</a></h2>
<p><img src="./assets/12-09-1.png" alt="" /></p>
<blockquote>
<p>✅ 这是一个优化问题，通过梯度下降找到极值点。</p>
</blockquote>
<p>P20</p>
<h2 id="solving-trajectory-optimization-problem"><a class="header" href="#solving-trajectory-optimization-problem">Solving Trajectory Optimization Problem</a></h2>
<h3 id="定义带约束的优化问题"><a class="header" href="#定义带约束的优化问题">定义带约束的优化问题</a></h3>
<p>Find a control sequence {\(a_t\)} that generates a state sequence {\(s_t\)} start from \(s_o\) minimizes</p>
<p>$$
\min h (s_r)+\sum _{t=0}^{T-1} h(s_t,a_t)
$$</p>
<blockquote>
<p>✅ 因为把时间离散化，此处用求和不用积分。</p>
</blockquote>
<p>subject to</p>
<p>$$
\begin{matrix}
f(s_t,a_t)-s_{t+1}=0\\
\text{ for } 0 \le t &lt; T
\end{matrix}
$$</p>
<blockquote>
<p>✅ 运动学方程，作为约束</p>
</blockquote>
<h3 id="转化为优化问题"><a class="header" href="#转化为优化问题">转化为优化问题</a></h3>
<p>The Lagrange function</p>
<p>$$
L(s,a,\lambda ) = h(s _ T)+ \sum _ {t=0} ^ {T-1} h(s _t,a _t) + \lambda _ {t+1}^T(f(s _t,a _t) - s _ {t+1})
$$</p>
<p>P27</p>
<h3 id="求解拉格朗日方程"><a class="header" href="#求解拉格朗日方程">求解拉格朗日方程</a></h3>
<p><img src="./assets/12-10-1.png" alt="" /></p>
<blockquote>
<p>✅ 拉格朗日方程，对每个变量求导，并令导数为零。因此得到右边方程组。<br />
✅ 右边方程组进一步整理，得到左边。<br />
✅ \(\lambda \) 类似于逆向仿真。<br />
✅ 公式 3：通过转为优化问题求 \(a\)．</p>
</blockquote>
<p>P30</p>
<h3 id="pontryagins-maximum-principle-for-discrete-systems"><a class="header" href="#pontryagins-maximum-principle-for-discrete-systems">Pontryagin’s Maximum Principle for discrete systems</a></h3>
<p><img src="./assets/12-11.png" alt="" /></p>
<p><img src="./assets/12-12.png" alt="" /></p>
<blockquote>
<p>✅ 方程组整理得到左边，称为 PMP 条件。是开环控制最优的必要条件。</p>
</blockquote>
<p>P32</p>
<h2 id="optimal-control"><a class="header" href="#optimal-control">Optimal Control</a></h2>
<p><strong>Open-loop Control</strong>:<br />
given a start state \(s_0\), compute sequence of actions {\(a_t\)} to reach the goal</p>
<p><img src="./assets/12-13.png" alt="" /></p>
<blockquote>
<p><strong>Shooting method</strong> directly applies PMP. However, it does not scale well to complicated problems such as motion control…<br />
\(<br>\)<br />
Need to be combined with collocation method, multiple shooting, etc. for those problems.<br />
\(<br>\)<br />
Or use derivative-free approaches.</p>
</blockquote>
<p><img src="./assets/12-14.png" alt="" /></p>
<blockquote>
<p>✅ 对于复杂函数，表现比较差，还需要借助其它方法。</p>
</blockquote>
<h1 id="闭环控制"><a class="header" href="#闭环控制">闭环控制</a></h1>
<p><img src="./assets/12-05.png" alt="" /></p>
<p>P34</p>
<h2 id="dynamic-programming"><a class="header" href="#dynamic-programming">Dynamic Programming</a></h2>
<p><img src="./assets/12-15.png" alt="" /> </p>
<p>希望找到一条最短路径到达另一个点，对这个问题用不同的方式建模，会得到不同的方法：</p>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>动态规划问题</td><td>Find a path {\(s_t\)} that minimizes</td><td>\(J(s_0)=\sum _ {t=0}^{ } h(s_t,s_{t+1})\)</td></tr>
<tr><td>轨迹问题</td><td>Find a sequence of action {\(a_t\)} that minimizes</td><td>\(J(s_0)=\sum _ {t=0}^{ } h(s_t,a_t)\)<br> subject to <br> \( s_{t+1}=f(s_t,a_t)\)</td></tr>
<tr><td>控制策略问题</td><td>Find a policy \( a_t=\pi (s_t,t)\)或 \( a_t=\pi (s_t)\)that minimizes</td><td>\(J(s_0)=\sum _ {t=0}^{ } h(s_t,a_t)\)<br>subject to  <br>\(s_{t+1}=f(s_t,a_t)\)</td></tr>
</tbody></table>
<p>P39</p>
<h2 id="bellmans-principle-of-optimality"><a class="header" href="#bellmans-principle-of-optimality">Bellman’s Principle of Optimality</a></h2>
<blockquote>
<p>✅ 针对控制策略问题，什么样的策略是最优策略？</p>
</blockquote>
<p><img src="./assets/12-16.png" alt="" /> </p>
<p>An optimal policy has the property that whatever the initial 
state and initial decision are, the remaining decisions must 
constitute an optimal policy with regard to the state resulting 
from the first decision.</p>
<p>\(^\ast \) The problem is said to have <strong>optimal substructure</strong></p>
<p>P40</p>
<h2 id="value-function"><a class="header" href="#value-function">Value Function</a></h2>
<p>Value of a state \(V(s)\) :</p>
<ul>
<li>the minimal total cost for finishing the task starting from \(s\)</li>
<li>the total cost for finishing the task starting from \(s\) using the optimal policy</li>
</ul>
<blockquote>
<p>✅ Value Funcron，计算从某个结点到 gool 的最小代价。<br />
✅ 后面动态规划原理跳过。</p>
</blockquote>
<p>P49</p>
<h2 id="the-bellman-equation"><a class="header" href="#the-bellman-equation">The Bellman Equation</a></h2>
<p>Mathematically, an optimal <strong>value function</strong> \(V(s)\) can be defined recursively as:</p>
<p>$$
V(s)=\min_{a} (h(s,a)+V(f(s,a)))
$$</p>
<blockquote>
<p>✅ h代表s状态下执行一步a的代价。f代表以s状态下执行一步a之后的状态。</p>
</blockquote>
<p>If we know this value function, the optimal <strong>policy</strong> can be computed as</p>
<p>$$
\pi (s)=\arg \min_{a} (h(s,a)+V(f(s,a)))
$$</p>
<blockquote>
<p>✅ pi代表一种策略，根据当前状态s找到最优的下一步a。<br />
✅ This arg max can be easily computed for discrete control problems.<br />
But there are not always closed-forms solution for continuous control problems.</p>
</blockquote>
<p>or</p>
<p>$$
\begin{matrix}
\pi (s)=\arg \min_{a} Q(s,a)\\
\text{where} \quad \quad  Q(s,a)=h(s,a)+V(f(s,a))
\end{matrix}
$$</p>
<p>Q-function称为State-action value function<br />
Learning \(V(s)\) and/or \(Q(s,a)\) is the core of optimal control / reinforcement learning methods</p>
<blockquote>
<p>✅ 强化学习最主要的目的是学习 \(V\) 函数和 \(Q\) 函数，如果 \(a\) 是有限状态，遍历即可。但在角色动画里，\(a\) 是连续状态。</p>
</blockquote>
<p>P52</p>
<h1 id="linear-quadratic-regulator-lqr"><a class="header" href="#linear-quadratic-regulator-lqr">Linear Quadratic Regulator (LQR)</a></h1>
<p><img src="./assets/12-17.png" alt="" /> </p>
<ul>
<li>LQR is a special class of optimal control problems with
<ul>
<li><strong>Linear</strong> dynamic function</li>
<li><strong>Quadratic</strong> objective function</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ LQR 是控制领域一类经典问题，它对原控制问题做了一些特定的约束。因为简化了问题，可以得到有特定公式的 \(Q\) 和 \(V\).</p>
</blockquote>
<p>P53</p>
<h2 id="a-very-simple-example"><a class="header" href="#a-very-simple-example">A very simple example</a></h2>
<h3 id="问题描述-9"><a class="header" href="#问题描述-9">问题描述</a></h3>
<p><img src="./assets/12-18.png" alt="" /> </p>
<p>Compute a target trajectory \(\tilde{x}(t)\) such that the simulated trajectory \(x(t)\) is a sine curve.</p>
<p><img src="./assets/12-19.png" alt="" /> </p>
<p>$$
\min _{(x_n,v_n,\tilde{x} _n)} \sum _{n=0}^{N} (\sin (t_n)-x_n)^2+\sum _{n=0}^{N}\tilde{x}^2_n 
$$</p>
<p>$$
\begin{align*}
s.t. \quad \quad v _ {n+1} &amp; = v _ n + h(k _p ( \tilde{x} _ n - x _ n) - k _ dv _ n ) \\
v _ {x+1} &amp; = x _ n + hv _ {n+1}
\end{align*}
$$</p>
<p>P54<br />
objective function</p>
<p>$$
\min s^T_TQ_Ts_T+\sum_{t=0}^{T} s^T_tQ_ts_t+a^T_tR_ta_t
$$</p>
<p>subject to dynamic function</p>
<p>$$
s_{t+1}=A_ts_t+B_ta_t   \quad \quad \text{for }   0\le t &lt;T 
$$</p>
<blockquote>
<p>✅ 目标函数是二次函数，运动学方程是线性函数。这是一个典型的 LQR 问题。</p>
</blockquote>
<p>P58</p>
<h3 id="推导一步"><a class="header" href="#推导一步">推导一步</a></h3>
<blockquote>
<p>✅ 由于存在optimal substructure，每次只需要考虑下一个状态的最优解。<br />
✅ 每一个状态基于下一个状态来计算，不断往下迭代，直到最后一个状态。<br />
✅ 最后一个状态的V的计算与a无关。<br />
✅ 计算完最后一个，再计算倒数第二个，依次往前推。</p>
</blockquote>
<p><img src="./assets/12-20-1.png" alt="" /> </p>
<p>P60<br />
公式整理得：</p>
<p><img src="./assets/12-20.png" alt="" /> </p>
<p>P61 
<img src="./assets/12-21.png" alt="" /> </p>
<blockquote>
<p>✅ 结论：最优策略与当前状态的关系是矩阵K的关系。</p>
</blockquote>
<p>P62<br />
当a取最小值时，求出V：</p>
<p><img src="./assets/12-22.png" alt="" /></p>
<blockquote>
<p>✅ \(V(S_{T-1})\)和\(V(S_{T})\)的形式基本一致，只是P的表示不同。 </p>
</blockquote>
<p>P63</p>
<h3 id="推导每一步"><a class="header" href="#推导每一步">推导每一步</a></h3>
<p><img src="./assets/12-23.png" alt="" /> </p>
<p>P64</p>
<h3 id="solution"><a class="header" href="#solution">Solution</a></h3>
<ul>
<li>LQR is a special class of optimal control problems with
<ul>
<li>Linear dynamic function</li>
<li>Quadratic objective function</li>
</ul>
</li>
<li>Solution of LQR is a linear feedback policy</li>
</ul>
<p><img src="./assets/12-24.png" alt="" /> </p>
<p>P65</p>
<h2 id="更复杂的情况"><a class="header" href="#更复杂的情况">更复杂的情况</a></h2>
<ul>
<li>How to deal with
<ul>
<li>Nonlinear dynamic function?</li>
<li>Non-quadratic objective function?</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 人体运动涉及到角度旋转，因此是非线性的。</p>
</blockquote>
<p>P68</p>
<h3 id="nonlinear-problems"><a class="header" href="#nonlinear-problems">Nonlinear problems</a></h3>
<p><img src="./assets/12-25.png" alt="" /> </p>
<blockquote>
<p>✅ 方法：把问题近似为线性问题。</p>
</blockquote>
<p>Approximate cost function as a quadratic function:</p>
<blockquote>
<p>✅ 目标函数：泰勒展开，保留二次。</p>
</blockquote>
<p>$$
h(s_t,a_t)\approx h(\bar{s}_t ,\bar{a}_t)+\nabla h(\bar{s}_t ,\bar{a}_t)\begin{bmatrix}
s_t-\bar{s} _t\\
a_t-\bar{a} _t
\end{bmatrix} + \frac{1}{2} \begin{bmatrix}
s_t-\bar{s} _t\\
a_t-\bar{a} _t
\end{bmatrix}^T\nabla^2h(\bar{s}_t ,\bar{a}_t)\begin{bmatrix}
s_t-\bar{s} _t\\
a_t-\bar{a} _t
\end{bmatrix}
$$</p>
<p>Approximate dynamic function as a linear function:</p>
<blockquote>
<p>✅ 转移函数：泰勒展开，保留一次或二次。</p>
</blockquote>
<p>$$
f(s_t,a_t)\approx f(\bar{s}_t ,\bar{a}_t)+\nabla f(\bar{s}_t ,\bar{a}_t)\begin{bmatrix}
s_t-\bar{s} _t\\
a_t-\bar{a} _t
\end{bmatrix}
$$</p>
<p>展开为一次项，对应解决算法：iLQR（iterative LQR） </p>
<p>Or a quadratic function:</p>
<p>$$
f(s_t,a_t)\approx \ast \ast \ast \frac{1}{2} \begin{bmatrix}
s_t-\bar{s} _t\\
a_t-\bar{a} _t
\end{bmatrix}^T\nabla^2f(\bar{s}_t ,\bar{a}_t)\begin{bmatrix}
s_t-\bar{s} _t\\
a_t-\bar{a} _t
\end{bmatrix}
$$</p>
<p>展开为二次项，对应解决算法：DDP（Differential Dynamic Programming）</p>
<p>P69</p>
<h3 id="相关应用"><a class="header" href="#相关应用">相关应用</a></h3>
<blockquote>
<p>🔎 [Muico et al 2011 - Composite Control of Physically Simulated Characters]</p>
</blockquote>
<blockquote>
<p>✅ 选择合适的 \(Q\) 和 \(R\)，需要一些工程上的技巧。<br />
✅ 为了求解方程，需要显式地建模运动学方程。</p>
</blockquote>
<p>P70</p>
<h2 id="model-based-method-vs-model-free-method"><a class="header" href="#model-based-method-vs-model-free-method">Model-based Method vs. Model-free Method</a></h2>
<blockquote>
<p>✅ Model Based 方法，要求 dynamic function 是已知的，但是实际上这个函数可能是（1）未知的（2）不精确的。<br />
✅ 因此Model Based 方法对于复杂问题难以应用，但对于简单问题非常高效。</p>
</blockquote>
<p>What if the dynamic function \(f(s,a)\) is not know?</p>
<blockquote>
<p>✅ \(f\) 未知只是把 \(f\) 当成一个黑盒子，仍需要根据 \(S_t\) 得到 \(S_{t＋1}\) .</p>
</blockquote>
<p>What if the dynamic function \(f(s,a)\) is not accurate?</p>
<blockquote>
<p>✅ 不准确来源于（1）测试量误差（2）问题简化</p>
</blockquote>
<p>What if the system has noise?</p>
<p>What if the system is highly nonlinear?</p>
<p>P72</p>
<h1 id="sampling-based-policy-optimization"><a class="header" href="#sampling-based-policy-optimization">Sampling-based Policy Optimization</a></h1>
<ul>
<li>
<p>Iterative methods</p>
<ul>
<li>Goal: find the optimal <strong>policy</strong> \(\pi (s;\theta )\) that minimize the objective \(J(\theta )=\sum_{t=0}^{}h(s_t,a_t) \)</li>
<li>Initialize policy parmeters \(\pi (x;\theta )\)</li>
<li>Repeat:
<ul>
<li>Propose a set of candidate parameters {\(\theta _i \)} according to \(\theta \)</li>
<li>Simulate the agent under the control of each \( \pi ( \theta _i)\) </li>
<li>Evaluate the objective function \( J (\theta_i )\)  on the simulated state-action sequences</li>
<li>Update the estimation of \(\theta \) based on {\( J (\theta_i )\)}</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Example: CMA-ES</p>
</li>
</ul>
<blockquote>
<p>✅ 基于采样的方法。</p>
</blockquote>
<p>P73</p>
<h2 id="example-locomotion-controller-with-linear-policy"><a class="header" href="#example-locomotion-controller-with-linear-policy">Example: Locomotion Controller with Linear Policy</a></h2>
<blockquote>
<p>🔎 [Liu et al. 2012 – Terrain Runner]</p>
</blockquote>
<p>P74</p>
<h3 id="stage-1a-open-loop-policy"><a class="header" href="#stage-1a-open-loop-policy">Stage 1a: Open-loop Policy</a></h3>
<p>Find open-loop control using SAMCON</p>
<p><img src="./assets/12-26.png" alt="" /> </p>
<blockquote>
<p>✅ 使用开环轨迹优化得到开环控制轨迹。</p>
</blockquote>
<p>P76</p>
<h3 id="stage-1b-linear-feedback-policy"><a class="header" href="#stage-1b-linear-feedback-policy">Stage 1b: Linear Feedback Policy</a></h3>
<p><img src="./assets/12-27.png" alt="" /></p>
<blockquote>
<p>✅ 使用反馈控制更新控制信号。由于假设了线性关系，根据偏离 offset 可直接得到调整 offset.</p>
</blockquote>
<p>P78</p>
<h3 id="stage-1b-reduced-order-closed-loop-policy"><a class="header" href="#stage-1b-reduced-order-closed-loop-policy">Stage 1b: Reduced-order Closed-loop Policy</a></h3>
<p><img src="./assets/12-28.png" alt="" /></p>
<blockquote>
<p>✅ 把 \(M\) 分解为两个矩阵，\(M_{AXB} = M_{AXC}\cdot M_{CXB}\) 如果 \(C\) 比较小，可以明显减少矩阵的参数量。<br />
✅ 好处：(1) 减少参数，减化优化过程。(2) 抹掉状态里不需要的信息。</p>
</blockquote>
<p>P79</p>
<h4 id="manually-selected-states-s"><a class="header" href="#manually-selected-states-s">Manually-selected States: s</a></h4>
<ul>
<li>Running: 12 dimensions</li>
</ul>
<p><img src="./assets/12-29.png" alt="" /> </p>
<blockquote>
<p>✅ （1）根结点旋转（2）质心位置（3）质心速度（4）支撑脚位置</p>
</blockquote>
<p>P80</p>
<h4 id="manually-selected-controls-a"><a class="header" href="#manually-selected-controls-a">Manually-selected Controls: a</a></h4>
<ul>
<li>for all skills: 9 dimensions</li>
</ul>
<p><img src="./assets/12-30.png" alt="" /></p>
<blockquote>
<p>✅ 仅对少数关节加反馈。</p>
</blockquote>
<p>P81</p>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<p>$$
\delta a=M\delta s+\hat{a} 
$$</p>
<ul>
<li>Optimize \(M\)
<ul>
<li>CMA, Covariance Matrix Adaption ([Hansen 2006])</li>
<li>For the running task:
<ul>
<li>#optimization variables: \(12 ^\ast 9 = 108 / (12^\ast 3+3 ^\ast 9) = 63\)</li>
</ul>
</li>
<li>12 minutes on 24 cores</li>
</ul>
</li>
</ul>
<p>P85</p>
<h1 id="optimal-control-leftrightarrow--reinforcement-learning"><a class="header" href="#optimal-control-leftrightarrow--reinforcement-learning">Optimal Control \(\Leftrightarrow \) Reinforcement Learning</a></h1>
<p>• RL shares roughly the same overall goal with Optimal Control</p>
<p>$$
\max \sum_{t=0}^{} r (s_t,a_t)
$$</p>
<blockquote>
<p>✅ 相同点：目标函数相同，是每一时刻的代价函数之和。 </p>
</blockquote>
<p>• But RL typically does not assume perfect knowledge of system</p>
<p><img src="./assets/12-30-1.png" alt="" /> </p>
<blockquote>
<p>✅ 最优控制要求有精确的运动方程，而 RL 不需要。</p>
</blockquote>
<ul>
<li>RL can still take advantage of a system model → model-based RL
<ul>
<li>The model can be learned from data<br />
$$
s_{t+1}=f(s_t,a_t;\theta )
$$</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ RL 通过不断与世界交互进行采样。</p>
</blockquote>
<p>P87</p>
<h2 id="markov-decision-process-mdp"><a class="header" href="#markov-decision-process-mdp">Markov Decision Process (MDP)</a></h2>
<p><img src="./assets/12-32.png" alt="" /></p>
<p><img src="./assets/12-31.png" alt="" /></p>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>State</td><td>\(\quad s_t \quad \quad \)</td></tr>
<tr><td>Action</td><td>\(\quad a_t\)</td></tr>
<tr><td>Policy</td><td>\(\quad \quad a_t\sim \pi (\cdot \mid s_t)\)</td></tr>
<tr><td>Transition probability</td><td>\(\quad \quad s_{t+1}\sim p  (\cdot \mid s_t,a_t)\)</td></tr>
<tr><td>Reward</td><td>\(\quad \quad r_t=r (s_t,a_t)\)</td></tr>
<tr><td>Return</td><td>\(R = \sum _{t}^{} \gamma ^t r (s_t,a_t)\)</td></tr>
</tbody></table>
<blockquote>
<p>✅ 真实场景中轨迹无限长，会导到 \(R\) 无限大。<br />
✅ 因此会使用小于 1 的 \(r,t\) 越大则对结果的影响越小。</p>
</blockquote>
<p>P88</p>
<h2 id="跟踪问题变成mdp问题"><a class="header" href="#跟踪问题变成mdp问题">跟踪问题变成MDP问题</a></h2>
<p>Trajectory</p>
<p>$$
\begin{matrix}
\tau =&amp; s_0 &amp; a_0 &amp; s_1 &amp; a_1 &amp; s_2&amp;\dots 
\end{matrix}
$$</p>
<p>Reward</p>
<p><img src="./assets/12-33.png" alt="" /></p>
<p>P90</p>
<h2 id="mdp问题的数学描述"><a class="header" href="#mdp问题的数学描述">MDP问题的数学描述</a></h2>
<blockquote>
<p>✅ Markov 性质：当当前状态已知的情况下，下一时刻状态只与当前状态相关，而不与之前任一时刻状态相关。</p>
</blockquote>
<p>MDP is a <strong>discrete-time</strong> stochastic control process.<br />
It provides a mathematical framework for modeling decision making in situations<br />
where outcomes are <strong>partly random and partly under the control of a decision maker</strong>.</p>
<p>A MDP problem:</p>
<p>\(\mathcal{M}\) = {\(S,A,p,r\)}<br />
\(S\): state space<br />
\(A\): action space<br />
p：状态转移概率，即运动学方程。<br />
r：代价函数。</p>
<p>P91</p>
<p>Solve for a policy \(\pi (a\mid s)\) that optimize the <strong>expected return</strong></p>
<p>$$
J=E[R]=E_{\tau \sim \pi }[\sum_{t}^{} \gamma ^tr(s_t,a_t)]
$$</p>
<blockquote>
<p>✅ 求解一个policy \(\pi \) 使期望最优，而不是直接找最优解。</p>
</blockquote>
<p>Overall all trajectories \(\tau \) = { \(s_0, a_0 , s_1 , a_1 ,  \dots  \)} induced by \(\pi \)</p>
<blockquote>
<p>✅ 假设 \(\pi \) 函数和 \(p\) 函数都是有噪音的，即得到的结果不是确定值，而是以一定概率得到某个结果。<strong>这是与最优控制问题的区别。</strong></p>
</blockquote>
<p>P93</p>
<h2 id="bellman-equations"><a class="header" href="#bellman-equations">Bellman Equations</a></h2>
<p>In optimal control:</p>
<p><img src="./assets/12-34.png" alt="" /></p>
<p>In RL control:</p>
<p><img src="./assets/12-35.png" alt="" /></p>
<blockquote>
<p>✅ 此处的\(\pi \)是某一个策略，而不是最优策略。</p>
</blockquote>
<p>P94</p>
<h2 id="how-to-solve-mdp"><a class="header" href="#how-to-solve-mdp">How to Solve MDP</a></h2>
<h3 id="value-based-methods"><a class="header" href="#value-based-methods">Value-based Methods</a></h3>
<ul>
<li>Learning the value function/Q-function using the Bellman equations</li>
<li>Evaluation the policy as</li>
</ul>
<p>$$
\pi (s) = \arg \min_{a} Q(s,a)
$$</p>
<ul>
<li>Typically used for <strong>discrete</strong> problems</li>
<li>Example: Value iteration, Q-l a ning, DQN, …</li>
</ul>
<p>P95</p>
<blockquote>
<p>🔎 DQN [Mnih et al. 2015, Human-level control through deep reinforcement learning]</p>
</blockquote>
<p>P96</p>
<h3 id="相关工作-4"><a class="header" href="#相关工作-4">相关工作</a></h3>
<blockquote>
<p>🔎 [Liu et al. 2017: Learning to Schedule Control Fragments ]</p>
</blockquote>
<p><img src="./assets/12-36.png" alt="" /></p>
<blockquote>
<p>✅ DQN 方法要求控制空间必须是离散的，但状态空间可以是连续的。<br />
✅ 因此可用于高阶的控制。</p>
</blockquote>
<p>P97</p>
<h3 id="policy-gradient-approach"><a class="header" href="#policy-gradient-approach">Policy Gradient approach</a></h3>
<ul>
<li>
<p>Learning the value function/Q-function using the Bellman equations</p>
</li>
<li>
<p>Compute approximate <strong>policy gradient</strong> according to value functions using Monte-Carlo method</p>
</li>
<li>
<p>Update the policy using policy gradient</p>
</li>
<li>
<p>Suitable for <strong>continuous</strong> problems</p>
</li>
<li>
<p>Exa pl : REINFORCE, TRPO, PPO, …</p>
</li>
</ul>
<blockquote>
<p>✅ policy grodient 是 Value function 对状态参数的求导。但这个没法算，所以用统计的方法得到近似。<br />
✅ 特点是显示定义 Dolicy 函数。对连续问题更有效。</p>
</blockquote>
<p>P98</p>
<h3 id="相关工作-5"><a class="header" href="#相关工作-5">相关工作</a></h3>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td><img src="./assets/12-37.png" alt="" /></td><td><img src="./assets/12-38.png" alt="" /></td><td><img src="./assets/12-39.png" alt="" /></td></tr>
<tr><td>[Liu et al. 2016. ControlGraphs]</td><td>[Liu et al. 2018]</td><td>[Peng et al. 2018. DeepMimic]</td></tr>
</tbody></table>
<p>P100</p>
<h2 id="generative-control-policies"><a class="header" href="#generative-control-policies">Generative Control Policies</a></h2>
<blockquote>
<p>✅ 使用RL learning，加上一点点轨迹优化的控制，就可以实现非常复杂的动作。</p>
</blockquote>
<blockquote>
<p>🔎 [Yao et al. Control VAE]</p>
</blockquote>
<p>P101</p>
<h1 id="whats-next"><a class="header" href="#whats-next">What’s Next?</a></h1>
<h2 id="digital-cerebellum"><a class="header" href="#digital-cerebellum">Digital Cerebellum</a></h2>
<p>Large Pretrained Model for Motion Control</p>
<p><img src="./assets/12-40.png" alt="" /></p>
<p>P102</p>
<h2 id="cross-modality-generation"><a class="header" href="#cross-modality-generation">Cross-modality Generation</a></h2>
<ul>
<li>\(\Leftrightarrow\) LLM \(\Leftrightarrow\) Text/Audio \(\Leftrightarrow\) Motion/Control \(\Leftrightarrow\) Image/Video \(\Leftrightarrow\)</li>
<li>Digital Actor?</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES105_mdbook/</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
